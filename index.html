<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Zombie Smasher</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        @import url("https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css");

        * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
            20% { opacity: 1; transform: translateX(-50%) translateY(0px); }
            80% { opacity: 1; transform: translateX(-50%) translateY(0px); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #1a1a1a;
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            overflow: hidden;
            flex-direction: column;
        }

        #game-container {
            position: relative;
            background-color: #333;
            border: 10px solid #fff;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
            overflow: hidden;
            width: 90vw;
            max-width: 1200px;
            aspect-ratio: 4/3;
            margin: 50px;
        }

        /* Mobile full-screen styles */
        @media screen and (max-width: 768px) and (orientation: portrait) {
            body {
                margin: 0;
                padding: 0;
                height: 100vh;
                height: 100dvh; /* Use dynamic viewport height */
            }

            #game-container {
                width: 100vw;
                height: 100vh;
                height: 100dvh;
                max-width: none;
                max-height: none;
                border: none;
                border-radius: 0;
                box-shadow: none;
            }

            /* Scale up UI elements for better visibility */
            #score-display, #highScoreDisplay, #weapon-display, #ammo-display, #health-display {
                font-size: clamp(0.6rem, 3vw, 1rem) !important;
            }

            h1 {
                font-size: clamp(1.2rem, 6vw, 3rem) !important;
            }

            p {
                font-size: clamp(0.5rem, 2.5vw, 0.8rem) !important;
            }

            #start-menu, #game-over-screen {
                padding: 15px !important;
            }

            .character-option {
                margin: 5px !important;
            }

            /* Mobile weapon drawer */
            #weapon-drawer-trigger {
                position: fixed;
                bottom: 20px;
                right: 20px;
                width: 60px;
                height: 60px;
                border-radius: 50%;
                background: rgba(0, 0, 0, 0.7);
                border: 2px solid rgba(255, 255, 255, 0.8);
                color: #fff;
                font-size: 1.2rem;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 101;
                transition: all 0.3s ease;
                cursor: pointer;
            }

            #weapon-drawer-trigger:hover {
                background: rgba(0, 0, 0, 0.9);
                transform: scale(1.1);
            }

            #weapon-drawer {
                position: fixed;
                bottom: 20px;
                right: 95px;
                background: rgba(0, 0, 0, 0.8);
                border-radius: 30px;
                padding: 10px;
                z-index: 100;
                display: flex;
                gap: 8px;
                transform: translateX(100px) scale(0);
                opacity: 0;
                transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
                pointer-events: none;
            }

            #weapon-drawer.open {
                transform: translateX(0) scale(1);
                opacity: 1;
                pointer-events: all;
            }

            .weapon-btn {
                width: 45px !important;
                height: 45px !important;
                border-radius: 50% !important;
                border: 2px solid rgba(255, 255, 255, 0.6) !important;
                background: rgba(255, 255, 255, 0.1) !important;
                color: #fff !important;
                font-size: 0.6rem !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                font-family: 'Press Start 2P', cursive !important;
                transition: all 0.2s ease !important;
                cursor: pointer !important;
            }

            .weapon-btn:hover {
                background: rgba(255, 255, 255, 0.2) !important;
                transform: scale(1.1) !important;
            }

            .weapon-btn.active {
                background: rgba(255, 255, 0, 0.3) !important;
                border-color: #ffff00 !important;
                color: #000 !important;
                font-weight: bold !important;
            }
        }

        /* Hide mobile weapon elements on desktop */
        #weapon-drawer-trigger, #weapon-drawer {
            display: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10;
            text-align: center;
            border-radius: 4px;
            display: none;
        }

        #start-menu {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        #game-over-screen {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            display: none;
        }

        h1 {
            font-size: clamp(1rem, 5vw, 2.5rem);
            margin-bottom: 20px;
            color: #ff4d4d;
            text-shadow: 2px 2px #000;
        }
        
        p {
            font-size: clamp(0.7rem, 2vw, 1.2rem);
            margin: 10px 0;
            text-shadow: 1px 1px #000;
        }

        .btn {
            padding: 12px 24px;
            font-size: clamp(0.8rem, 2.5vw, 1.2rem);
            font-family: 'Press Start 2P', cursive;
            background-color: #4CAF50;
            color: white;
            border: 2px solid #388E3C;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 4px #2e7d32;
            margin-top: 20px;
        }
        
        .btn:hover {
            background-color: #5cb85c;
            transform: translateY(2px);
            box-shadow: 0 2px #2e7d32;
        }
        
        #score-display {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: clamp(0.7rem, 2vw, 1.2rem);
            color: #fff;
            text-shadow: 1px 1px #000;
            z-index: 5;
        }
        
        #weapon-display {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: clamp(0.7rem, 2vw, 1.2rem);
            color: #fff;
            text-shadow: 1px 1px #000;
            z-index: 5;
        }

        #ammo-display {
            position: absolute;
            top: 40px;
            right: 10px;
            font-size: clamp(0.7rem, 2vw, 1.2rem);
            color: #fff;
            text-shadow: 1px 1px #000;
            z-index: 5;
        }

        #highScoreDisplay {
            position: absolute;
            top: 40px;
            left: 10px;
            font-size: clamp(0.7rem, 2vw, 1.2rem);
            color: #fff;
            text-shadow: 1px 1px #000;
            z-index: 5;
        }

        #health-display {
            position: absolute;
            top: 90px;
            right: 10px;
            font-size: clamp(1rem, 2.5vw, 1.3rem);
            z-index: 5;
            text-shadow: 1px 1px #000;
            line-height: 1;
        }

        #xp-display {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #FFD700;
            font-weight: bold;
            font-size: clamp(0.8rem, 2.5vw, 1rem);
            z-index: 5;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }


        #character-selection {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .character-option {
            width: 80px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 8px;
            transition: border-color 0.2s ease;
            background-color: rgba(255, 255, 255, 0.1);
            padding: 10px;
        }

        .character-option:hover {
            border-color: #fff;
        }

    </style>
</head>
<body>
    <div id="game-container">
        <div id="score-display">Session XP: 0</div>
        <div id="highScoreDisplay">Best Session: 0 XP</div>
        <div id="xp-display">XP: 0</div>
        <div id="weapon-display">Weapon: Pistol</div>
        <div id="ammo-display">Ammo: Inf</div>
        <div id="health-display">❤️❤️❤️</div>
        <canvas id="gameCanvas"></canvas>
        <div id="game-ui">
            <div id="start-menu">
                <h1>Zombie Smasher</h1>
                <p id="startHighScore">High Score: 0</p>
                <p>Choose your character to begin</p>
                <div id="character-selection">
                    <div class="character-option" id="char1">
                        <canvas id="char1Canvas" width="80" height="100"></canvas>
                    </div>
                    <div class="character-option" id="char2">
                        <canvas id="char2Canvas" width="80" height="100"></canvas>
                    </div>
                    <div class="character-option" id="char3">
                        <canvas id="char3Canvas" width="80" height="100"></canvas>
                    </div>
                </div>
                <div id="instructions" style="text-align: center; margin: 20px 0;">
                    <p id="movement-instructions">Move with WASD or Arrow Keys</p>
                    <p>Aim with the mouse and shoot with click or spacebar</p>
                    <p>Collect mystery chests to get more ammo!</p>
                </div>
                <div style="font-size: 0.6em; line-height: 2rem; margin: 5px auto;">
                    <p>Switch weapons: <br/>1 - Pistol | 2 - Shotgun<br/>3 - Frag Grenade | 4 - Nuke<br/>5 - Missile</p>
                </div>
            </div>
            <div id="game-over-screen">
                <h1>Game Over</h1>
                <p>Session XP: <span id="finalScore">0</span></p>
                <p>Best Session: <span id="highScore">0</span></p>
                <button id="restartButton" class="btn">Play Again</button>
            </div>
        </div>

        <!-- Mobile weapon drawer -->
        <div id="weapon-drawer-trigger">⚔️</div>
        <div id="weapon-drawer">
            <button class="weapon-btn" data-weapon="pistol">P</button>
            <button class="weapon-btn" data-weapon="shotgun">S</button>
            <button class="weapon-btn" data-weapon="assaultRifle">A</button>
            <button class="weapon-btn" data-weapon="fragGrenade">G</button>
            <button class="weapon-btn" data-weapon="nuke">N</button>
            <button class="weapon-btn" data-weapon="missile">M</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Mobile detection and zoom settings
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const mobileZoomFactor = 0.7;

        // Function to apply mobile zoom - DISABLED for now to fix rendering issues
        function applyMobileZoom() {
            // Disabled zoom transform to fix mobile rendering issues
            // Will use alternative approach with larger game area
        }

        // Show weapon change notification for mobile
        function showWeaponChangeNotification() {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(0, 0, 0, 0.8);
                color: #fff;
                padding: 10px 20px;
                border-radius: 25px;
                font-family: 'Press Start 2P', cursive;
                font-size: 0.8rem;
                z-index: 1000;
                pointer-events: none;
                animation: fadeInOut 2s ease-in-out;
            `;

            const weaponNames = {
                pistol: 'Pistol (∞)',
                shotgun: 'Shotgun',
                fragGrenade: 'Frag Grenade',
                nuke: 'Nuke',
                missile: 'Missile'
            };

            notification.textContent = weaponNames[currentWeapon] || currentWeapon;
            document.body.appendChild(notification);

            // Remove after animation
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 2000);
        }

        // Resize canvas function
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;

            // Mobile-specific adjustments
            if (isMobile) {
                // Make the canvas resolution higher for more viewing area
                canvas.width = Math.max(canvas.width, window.innerWidth);
                canvas.height = Math.max(canvas.height, window.innerHeight);
            }

            // Set up canvas context
            ctx.fillStyle = '#fff';
            ctx.font = 'clamp(0.7rem, 2vw, 1.2rem) "Press Start 2P"';
            ctx.textAlign = 'start';
            ctx.textBaseline = 'top';

            // Initialize game elements
            if (typeof createWalls === 'function') {
                createWalls();
                generateDemoStructures();
            }
            if (typeof player !== 'undefined') {
                player.x = 0; // Start at grid-aligned building center
                player.y = 0;
                initializeCamera(); // Initialize camera system
            }
        }

        const scoreDisplay = document.getElementById('score-display');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const xpDisplay = document.getElementById('xp-display');
        const weaponDisplay = document.getElementById('weapon-display');
        const ammoDisplay = document.getElementById('ammo-display');
        const healthDisplay = document.getElementById('health-display');
        const gameUI = document.getElementById('game-ui');
        const startMenu = document.getElementById('start-menu');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreSpan = document.getElementById('finalScore');
        const highScoreSpan = document.getElementById('highScore');
        const startHighScoreSpan = document.getElementById('startHighScore');
        const restartButton = document.getElementById('restartButton');
        const char1Button = document.getElementById('char1');
        const char2Button = document.getElementById('char2');
        const char3Button = document.getElementById('char3');
        const char1Canvas = document.getElementById('char1Canvas');
        const char2Canvas = document.getElementById('char2Canvas');
        const char3Canvas = document.getElementById('char3Canvas');
        const ctx1 = char1Canvas.getContext('2d');
        const ctx2 = char2Canvas.getContext('2d');
        const ctx3 = char3Canvas.getContext('2d');

        let isGameOver = true;
        let highSessionXP = parseInt(localStorage.getItem('zombieGameHighSessionXP')) || 0;

        // XP System for Meta Progression
        let totalXP = 0;
        let sessionXP = 0;

        // Load saved XP from localStorage
        function loadProgress() {
            const saved = localStorage.getItem('zombieGameProgress');
            if (saved) {
                const progress = JSON.parse(saved);
                totalXP = progress.totalXP || 0;
            }
        }

        // Save progress to localStorage
        function saveProgress() {
            const progress = {
                totalXP: totalXP
            };
            localStorage.setItem('zombieGameProgress', JSON.stringify(progress));
        }

        // Award XP for killing enemies
        function awardXP(amount) {
            totalXP += amount;
            sessionXP += amount;
            saveProgress();
            updateXPDisplay();
            updateSessionXPDisplay();
        }

        // Update session XP display
        function updateSessionXPDisplay() {
            scoreDisplay.textContent = `Session XP: ${sessionXP}`;
        }

        // Update XP display
        function updateXPDisplay() {
            xpDisplay.textContent = `XP: ${totalXP}`;
        }

        // Check and update high session XP
        function checkHighSessionXP() {
            if (sessionXP > highSessionXP) {
                highSessionXP = sessionXP;
                localStorage.setItem('zombieGameHighSessionXP', highSessionXP.toString());
                highScoreDisplay.textContent = `Best Session: ${highSessionXP} XP`;
                return true; // New record
            }
            return false;
        }
        let playerHealth = 3;
        const maxHealth = 3;
        let invincibilityFrames = 0;
        const invincibilityDuration = 1000; // 1 second of invincibility

        // Power-up system
        let activePowerUps = {
            speedBoost: 0,
            damageMultiplier: 0,
            shield: 0,
            multiShot: 0,
            rapidFire: 0
        };

        // Loot types and probabilities
        const lootTypes = {
            AMMO: 'ammo',
            HEALTH: 'health',
            SCORE_BONUS: 'scoreBonus',
            SPEED_BOOST: 'speedBoost',
            DAMAGE_MULTIPLIER: 'damageMultiplier',
            SHIELD: 'shield',
            MULTI_SHOT: 'multiShot',
            RAPID_FIRE: 'rapidFire'
        };
        let animationId;
        
        let mouseX = 0;
        let mouseY = 0;
        let mouseMoved = false;

        const player = {
            x: 0,
            y: 0,
            radius: 15,
            color: '#00f',
            speed: 5,
            frame: 0,
            lastFrameChange: Date.now(),
            variant: 0,
            direction: 'down',
            isShooting: false,
            shootingEndTime: 0
        };
        
        const characterVariants = [
            // Variant 1: Dark Gray Tactical - Original Design
            {
                skinColor: '#D2A679',     // Tan skin
                hoodColor: '#2A2A2A',     // Dark gray hood
                hoodShadow: '#1A1A1A',   // Darker shadow
                vestGray: '#606060',     // Gray vest
                vestDark: '#404040',     // Dark vest
                orangeGear: '#FF8800',   // Bright orange
                pantsGreen: '#5A6B2E',  // Olive green
                pantsDark: '#454F24',    // Dark green
                bootsBlack: '#0F0F0F'    // Black boots
            },
            // Variant 2: Black Tactical - Darker Ops
            {
                skinColor: '#8B4513',     // Dark skin
                hoodColor: '#1A1A1A',     // Black hood
                hoodShadow: '#0A0A0A',   // Very dark shadow
                vestGray: '#3A3A3A',     // Dark gray vest
                vestDark: '#2A2A2A',     // Very dark vest
                orangeGear: '#CC6600',   // Dark orange
                pantsGreen: '#2F3D1A',  // Dark olive
                pantsDark: '#1F2A10',    // Very dark green
                bootsBlack: '#050505'    // Very black boots
            },
            // Variant 3: Desert Tactical - Sandy/Brown Theme
            {
                skinColor: '#A0522D',     // Medium skin
                hoodColor: '#5D4E37',     // Brown hood
                hoodShadow: '#4A3C2A',   // Dark brown shadow
                vestGray: '#8B7355',     // Sandy gray vest
                vestDark: '#6F5A42',     // Dark brown vest
                orangeGear: '#FF9933',   // Bright sandy orange
                pantsGreen: '#6B5B2F',  // Desert green
                pantsDark: '#544725',    // Dark desert
                bootsBlack: '#2F1B14'    // Dark brown boots
            }
        ];

        let playerDirection = { x: 0, y: -1 };
        let currentWeapon = 'axe';

        // Gamepad detection and management
        function detectGamepad() {
            const gamepads = navigator.getGamepads();
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i]) {
                    gamepad = gamepads[i];
                    gamepadIndex = i;
                    console.log(`Xbox Controller connected: ${gamepad.id}`);
                    return;
                }
            }
        }

        function disconnectGamepad() {
            gamepad = null;
            gamepadIndex = -1;
            console.log('Controller disconnected');
        }

        // Menu navigation functions
        function updateMenuSelection() {
            const buttons = [char1Button, char2Button, char3Button];
            buttons.forEach((btn, index) => {
                if (index === selectedCharacter) {
                    btn.style.border = '3px solid #ff6600';
                    btn.style.transform = 'scale(1.1)';
                } else {
                    btn.style.border = '2px solid #333';
                    btn.style.transform = 'scale(1)';
                }
            });
        }

        function handleMenuInput() {
            if (!gamepad) {
                detectGamepad();
                return;
            }

            if (!isInMenu) return;

            // Update gamepad state
            gamepad = navigator.getGamepads()[gamepadIndex];
            if (!gamepad) return;

            // D-pad or left stick for character selection
            const leftPressed = getButtonPressed(14); // D-pad left
            const rightPressed = getButtonPressed(15); // D-pad right
            const leftStick = applyDeadzone(gamepad.axes[0]);
            const aPressed = getButtonPressed(0); // A button

            // Debug logging
            if (leftPressed || rightPressed || aPressed || Math.abs(leftStick) > 0.1) {
                console.log(`Menu Input - Left: ${leftPressed}, Right: ${rightPressed}, A: ${aPressed}, Stick: ${leftStick.toFixed(2)}, Selected: ${selectedCharacter}`);
            }

            // Navigate left/right between characters
            if (leftPressed || (leftStick < -0.5 && !window.lastLeftStick)) {
                selectedCharacter = (selectedCharacter - 1 + 3) % 3;
                audioManager.playSound('buttonClick');
                updateMenuSelection();
                console.log(`Selected character ${selectedCharacter}`);
            } else if (rightPressed || (leftStick > 0.5 && !window.lastLeftStick)) {
                selectedCharacter = (selectedCharacter + 1) % 3;
                audioManager.playSound('buttonClick');
                updateMenuSelection();
                console.log(`Selected character ${selectedCharacter}`);
            }

            // Store last left stick state for edge detection
            window.lastLeftStick = (leftStick > 0.5 || leftStick < -0.5);

            // A button to select character and start game
            if (aPressed) {
                console.log(`Starting game with character ${selectedCharacter}`);
                player.variant = selectedCharacter;
                startGame();
            }
        }

        // Gamepad utility functions
        function applyDeadzone(value, deadzone = GAMEPAD_DEADZONE) {
            return Math.abs(value) < deadzone ? 0 : value;
        }

        function getButtonPressed(buttonIndex) {
            if (!gamepad) return false;
            const pressed = gamepad.buttons[buttonIndex]?.pressed || false;
            const wasPressed = lastGamepadButtons[buttonIndex] || false;
            lastGamepadButtons[buttonIndex] = pressed;
            return pressed && !wasPressed; // Edge detection for single press
        }

        function getButtonHeld(buttonIndex) {
            if (!gamepad) return false;
            return gamepad.buttons[buttonIndex]?.pressed || false;
        }
        let ammo = {
            pistol: Infinity,
            shotgun: 10,
            assaultRifle: 30,
            fragGrenade: 5,
            nuke: 1,
            missile: 1
        };
        const maxAmmo = {
            pistol: Infinity,
            shotgun: 10,
            assaultRifle: 30,
            fragGrenade: 5,
            nuke: 1,
            missile: 1
        };

        let keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            w: false,
            s: false,
            a: false,
            d: false
        };

        // Mobile accelerometer variables
        let accelerometerData = { x: 0, y: 0, z: 0 };
        let motionPermissionGranted = false;

        // Shooting state tracking
        let spacePressed = false;
        let mousePressed = false;

        // Automatic firing for assault rifle
        let autoFireInterval = null;
        const ASSAULT_RIFLE_FIRE_RATE = 150; // milliseconds between shots

        // Xbox Controller Support (Twin Stick Shooter)
        let gamepad = null;
        let gamepadIndex = -1;
        let lastGamepadButtons = {};
        const GAMEPAD_DEADZONE = 0.2;
        const GAMEPAD_AIM_SENSITIVITY = 3;
        let gamepadAimX = 0;
        let gamepadAimY = 0;

        // Gamepad Vibration System
        function vibrateGamepad(weakMagnitude = 0.0, strongMagnitude = 0.0, duration = 200) {
            if (!gamepad || !gamepad.vibrationActuator) return;

            try {
                // Clamp values between 0.0 and 1.0
                weakMagnitude = Math.max(0.0, Math.min(1.0, weakMagnitude));
                strongMagnitude = Math.max(0.0, Math.min(1.0, strongMagnitude));

                gamepad.vibrationActuator.playEffect("dual-rumble", {
                    startDelay: 0,
                    duration: duration,
                    weakMagnitude: weakMagnitude,     // High frequency (subtle)
                    strongMagnitude: strongMagnitude  // Low frequency (strong)
                });
            } catch (error) {
                // Vibration not supported or failed - silently ignore
                console.log('Gamepad vibration not supported:', error.message);
            }
        }

        // Menu navigation with controller
        let selectedCharacter = 0; // 0, 1, or 2 for char1, char2, char3
        let isInMenu = true;

        let zombies = [];
        let skeletons = [];
        let playerBullets = [];
        let enemyBullets = [];
        let missiles = [];
        let explosions = [];
        let chests = [];
        let muzzleFlashes = [];
        let bloodSplatters = [];
        let damageNumbers = [];
        let fragments = [];

        // Screen shake system
        let screenShake = {
            intensity: 0,
            duration: 0,
            x: 0,
            y: 0
        };
        
        let lastZombieSpawn = 0;
        const ZOMBIE_SPAWN_INTERVAL = 3000;
        const ZOMBIE_ANIM_SPEED = 150;
        const PLAYER_ANIM_SPEED = 100;
        
        let lastSkeletonSpawn = 0;
        const SKELETON_SPAWN_INTERVAL = 8000;
        const SKELETON_ANIM_SPEED = 150;
        
        let lastChestSpawn = 0;
        const CHEST_SPAWN_INTERVAL = 15000;

        const MAX_ZOMBIES = 10;
        const MAX_SKELETONS = 10;

        // Audio System
        class AudioManager {
            constructor() {
                this.audioContext = null;
                this.masterVolume = 0.7;
                this.sfxVolume = 0.8;
                this.musicVolume = 0.3;
                this.sounds = {};
                this.currentMusic = null;
                this.enabled = true;
                this.initialized = false;
            }

            async init() {
                if (this.initialized) return;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.createSounds();
                    this.initialized = true;
                } catch (error) {
                    console.warn('Audio not supported:', error);
                    this.enabled = false;
                }
            }

            createSounds() {
                // Create procedural sounds using Web Audio API
                this.sounds = {
                    pistol: this.createPistolSound(),
                    assaultRifle: this.createAssaultRifleSound(),
                    shotgun: this.createGunSound(150, 0.15, 'square'),
                    fragGrenade: this.createFragGrenadeSound(),
                    nuke: this.createExplosionSound(80, 0.3),
                    missile: this.createMissileSound(),
                    enemyDeath: this.createDeathSound(),
                    zombieDeath: this.createZombieDeathSound(),
                    skeletonDeath: this.createSkeletonDeathSound(),
                    playerHit: this.createHitSound(),
                    chestPickup: this.createPickupSound(),
                    buttonClick: this.createClickSound(),
                    axeChop: this.createAxeChopSound(),
                    doorOpen: this.createDoorSound()
                };
            }

            createGunSound(frequency, duration, waveType = 'square') {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    const filterNode = this.audioContext.createBiquadFilter();

                    oscillator.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);

                    oscillator.type = waveType;
                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(frequency * 0.3, this.audioContext.currentTime + duration);

                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(1000, this.audioContext.currentTime);

                    gainNode.gain.setValueAtTime(this.sfxVolume * this.masterVolume * 0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);

                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration);
                };
            }

            createRealisticPistolSound() {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    const now = this.audioContext.currentTime;
                    const baseVolume = this.sfxVolume * this.masterVolume * 0.4;

                    // Add slight variations to each shot for realism
                    const variation = 0.9 + Math.random() * 0.2; // 0.9 to 1.1 multiplier
                    const pitchVariation = 0.95 + Math.random() * 0.1; // Slight pitch variation

                    // Layer 1: Initial crack (white noise burst)
                    const noiseBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.02, this.audioContext.sampleRate);
                    const noiseData = noiseBuffer.getChannelData(0);
                    for (let i = 0; i < noiseData.length; i++) {
                        noiseData[i] = (Math.random() * 2 - 1) * (1 - i / noiseData.length); // Fade out quickly
                    }
                    const noiseSource = this.audioContext.createBufferSource();
                    const noiseGain = this.audioContext.createGain();
                    const noiseFilter = this.audioContext.createBiquadFilter();

                    noiseSource.buffer = noiseBuffer;
                    noiseFilter.type = 'bandpass'; // Bandpass to limit both high and low extremes
                    noiseFilter.frequency.setValueAtTime(1200, now); // Lower center frequency
                    noiseFilter.Q.setValueAtTime(1.5, now); // Moderate Q for more natural sound

                    noiseSource.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(this.audioContext.destination);

                    noiseGain.gain.setValueAtTime(baseVolume * 0.8 * variation, now);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.02);

                    noiseSource.start(now);

                    // Layer 2: Main body (more realistic, less harsh)
                    const mainOsc = this.audioContext.createOscillator();
                    const mainGain = this.audioContext.createGain();
                    const mainFilter = this.audioContext.createBiquadFilter();

                    mainOsc.type = 'triangle'; // Softer than sawtooth
                    mainOsc.frequency.setValueAtTime(180 * pitchVariation, now); // Lower starting frequency
                    mainOsc.frequency.exponentialRampToValueAtTime(40 * pitchVariation, now + 0.06); // Faster decay

                    mainFilter.type = 'lowpass'; // Low-pass instead of bandpass to remove harsh highs
                    mainFilter.frequency.setValueAtTime(600, now); // Lower cutoff frequency
                    mainFilter.frequency.exponentialRampToValueAtTime(200, now + 0.06); // Sweep down

                    mainOsc.connect(mainFilter);
                    mainFilter.connect(mainGain);
                    mainGain.connect(this.audioContext.destination);

                    mainGain.gain.setValueAtTime(baseVolume * variation * 0.7, now); // Slightly quieter
                    mainGain.gain.exponentialRampToValueAtTime(0.01, now + 0.06);

                    mainOsc.start(now);
                    mainOsc.stop(now + 0.06);

                    // Layer 3: Bass thump (low frequency punch)
                    const bassOsc = this.audioContext.createOscillator();
                    const bassGain = this.audioContext.createGain();
                    const bassFilter = this.audioContext.createBiquadFilter();

                    bassOsc.type = 'sine';
                    bassOsc.frequency.setValueAtTime(60 * pitchVariation, now);
                    bassOsc.frequency.exponentialRampToValueAtTime(30 * pitchVariation, now + 0.12);

                    bassFilter.type = 'lowpass';
                    bassFilter.frequency.setValueAtTime(200, now);

                    bassOsc.connect(bassFilter);
                    bassFilter.connect(bassGain);
                    bassGain.connect(this.audioContext.destination);

                    bassGain.gain.setValueAtTime(baseVolume * 0.6 * variation, now);
                    bassGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);

                    bassOsc.start(now);
                    bassOsc.stop(now + 0.12);

                    // Layer 4: More realistic mechanical action (using filtered noise)
                    const mechanicalBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.015, this.audioContext.sampleRate);
                    const mechanicalData = mechanicalBuffer.getChannelData(0);

                    // Create short burst of noise for mechanical sound
                    for (let i = 0; i < mechanicalData.length; i++) {
                        mechanicalData[i] = (Math.random() * 2 - 1) * (1 - i / mechanicalData.length);
                    }

                    const mechanicalSource = this.audioContext.createBufferSource();
                    const mechanicalGain = this.audioContext.createGain();
                    const mechanicalFilter = this.audioContext.createBiquadFilter();

                    mechanicalSource.buffer = mechanicalBuffer;
                    mechanicalFilter.type = 'bandpass';
                    mechanicalFilter.frequency.setValueAtTime(800, now + 0.04); // Metal contact frequency
                    mechanicalFilter.Q.setValueAtTime(3, now + 0.04); // Sharp resonance

                    mechanicalSource.connect(mechanicalFilter);
                    mechanicalFilter.connect(mechanicalGain);
                    mechanicalGain.connect(this.audioContext.destination);

                    mechanicalGain.gain.setValueAtTime(baseVolume * 0.15 * variation, now + 0.04);
                    mechanicalGain.gain.exponentialRampToValueAtTime(0.01, now + 0.055);

                    mechanicalSource.start(now + 0.04);
                };
            }

            createPistolSound() {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    const now = this.audioContext.currentTime;
                    const baseVolume = this.sfxVolume * this.masterVolume * 0.9;
                    const variation = 0.9 + Math.random() * 0.2;
                    const pitchVar = 0.95 + Math.random() * 0.1;

                    // 1. EXPLOSIVE BLAST - Deep gunpowder explosion (instant, massive)
                    const blastBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.06, this.audioContext.sampleRate);
                    const blastData = blastBuffer.getChannelData(0);
                    for (let i = 0; i < blastData.length; i++) {
                        const decay = Math.pow(1 - i / blastData.length, 1.8); // Sustained explosion
                        // Create explosive burst with mixed frequencies
                        blastData[i] = (Math.random() * 2 - 1) * decay;
                    }

                    const blastSource = this.audioContext.createBufferSource();
                    const blastGain = this.audioContext.createGain();
                    const blastFilter = this.audioContext.createBiquadFilter();

                    blastSource.buffer = blastBuffer;
                    blastFilter.type = 'bandpass';
                    blastFilter.frequency.setValueAtTime(800 * pitchVar, now); // Mid-range, not tinny
                    blastFilter.Q.setValueAtTime(0.8, now); // Wide, not sharp

                    blastSource.connect(blastFilter);
                    blastFilter.connect(blastGain);
                    blastGain.connect(this.audioContext.destination);

                    blastGain.gain.setValueAtTime(baseVolume * 2.2 * variation, now); // EVEN MORE MASSIVE volume
                    blastGain.gain.exponentialRampToValueAtTime(0.01, now + 0.06);
                    blastSource.start(now);

                    // 2. DEEP BOOM - Raw gunpowder thump (overlapping)
                    const boomOsc = this.audioContext.createOscillator();
                    const boomGain = this.audioContext.createGain();
                    const boomFilter = this.audioContext.createBiquadFilter();

                    boomOsc.type = 'sawtooth'; // Rich, raw sound
                    boomOsc.frequency.setValueAtTime(120 * pitchVar, now + 0.005); // Deeper than semi-auto
                    boomOsc.frequency.exponentialRampToValueAtTime(40 * pitchVar, now + 0.08);

                    boomFilter.type = 'lowpass';
                    boomFilter.frequency.setValueAtTime(500, now + 0.005); // Less filtered, more raw

                    boomOsc.connect(boomFilter);
                    boomFilter.connect(boomGain);
                    boomGain.connect(this.audioContext.destination);

                    boomGain.gain.setValueAtTime(baseVolume * 1.8 * variation, now + 0.005); // LOUDER recoil
                    boomGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

                    boomOsc.start(now + 0.005);
                    boomOsc.stop(now + 0.08);

                    // 3. HAMMER CLICK - Revolver hammer action (much later)
                    const hammerOsc = this.audioContext.createOscillator();
                    const hammerGain = this.audioContext.createGain();
                    const hammerFilter = this.audioContext.createBiquadFilter();

                    hammerOsc.type = 'square';
                    hammerOsc.frequency.setValueAtTime(1200, now + 0.15); // Sharp click
                    hammerOsc.frequency.exponentialRampToValueAtTime(800, now + 0.16);

                    hammerFilter.type = 'bandpass';
                    hammerFilter.frequency.setValueAtTime(1500, now + 0.15);
                    hammerFilter.Q.setValueAtTime(3, now + 0.15);

                    hammerOsc.connect(hammerFilter);
                    hammerFilter.connect(hammerGain);
                    hammerGain.connect(this.audioContext.destination);

                    hammerGain.gain.setValueAtTime(baseVolume * 0.4 * variation, now + 0.15);
                    hammerGain.gain.exponentialRampToValueAtTime(0.01, now + 0.16);

                    hammerOsc.start(now + 0.15);
                    hammerOsc.stop(now + 0.16);

                    // 4. LONG ROLLING ECHO - Western canyon echo
                    const echoBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.4, this.audioContext.sampleRate);
                    const echoData = echoBuffer.getChannelData(0);
                    for (let i = 0; i < echoData.length; i++) {
                        const decay = Math.pow(1 - i / echoData.length, 0.8); // Very slow fade
                        // Add rolling reflections like canyon walls
                        const roll = Math.sin(i * 0.0003) * 0.5 + Math.sin(i * 0.0007) * 0.3;
                        echoData[i] = (Math.random() * 2 - 1) * decay * (0.4 + roll);
                    }

                    const echoSource = this.audioContext.createBufferSource();
                    const echoGain = this.audioContext.createGain();
                    const echoFilter = this.audioContext.createBiquadFilter();

                    echoSource.buffer = echoBuffer;
                    echoFilter.type = 'lowpass';
                    echoFilter.frequency.setValueAtTime(600, now + 0.08); // Keep some mids
                    echoFilter.frequency.exponentialRampToValueAtTime(120, now + 0.48);

                    echoSource.connect(echoFilter);
                    echoFilter.connect(echoGain);
                    echoGain.connect(this.audioContext.destination);

                    echoGain.gain.setValueAtTime(baseVolume * 0.5 * variation, now + 0.08); // Strong echo
                    echoGain.gain.exponentialRampToValueAtTime(0.001, now + 0.48);
                    echoSource.start(now + 0.08);
                };
            }

            createAssaultRifleSound() {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    const now = this.audioContext.currentTime;
                    const baseVolume = this.sfxVolume * this.masterVolume * 0.5;

                    // Variation for each shot
                    const variation = 0.9 + Math.random() * 0.2;
                    const pitchVar = 0.95 + Math.random() * 0.1;

                    // Layer 1: Sharp crack (supersonic bullet snap)
                    const crackBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.008, this.audioContext.sampleRate);
                    const crackData = crackBuffer.getChannelData(0);

                    // Very sharp attack, immediate decay for crack
                    for (let i = 0; i < crackData.length; i++) {
                        const decay = Math.pow(1 - i / crackData.length, 3); // Sharp exponential decay
                        crackData[i] = (Math.random() * 2 - 1) * decay;
                    }

                    const crackSource = this.audioContext.createBufferSource();
                    const crackGain = this.audioContext.createGain();
                    const crackFilter = this.audioContext.createBiquadFilter();

                    crackSource.buffer = crackBuffer;
                    crackFilter.type = 'highpass';
                    crackFilter.frequency.setValueAtTime(3000 * pitchVar, now);

                    crackSource.connect(crackFilter);
                    crackFilter.connect(crackGain);
                    crackGain.connect(this.audioContext.destination);

                    crackGain.gain.setValueAtTime(baseVolume * 0.9 * variation, now);
                    crackGain.gain.exponentialRampToValueAtTime(0.01, now + 0.008);

                    crackSource.start(now);

                    // Layer 2: Muzzle blast (powder explosion)
                    const blastOsc = this.audioContext.createOscillator();
                    const blastGain = this.audioContext.createGain();
                    const blastFilter = this.audioContext.createBiquadFilter();

                    blastOsc.type = 'sawtooth';
                    blastOsc.frequency.setValueAtTime(150 * pitchVar, now);
                    blastOsc.frequency.exponentialRampToValueAtTime(35 * pitchVar, now + 0.04);

                    blastFilter.type = 'lowpass';
                    blastFilter.frequency.setValueAtTime(800 * pitchVar, now);
                    blastFilter.frequency.exponentialRampToValueAtTime(100, now + 0.04);

                    blastOsc.connect(blastFilter);
                    blastFilter.connect(blastGain);
                    blastGain.connect(this.audioContext.destination);

                    blastGain.gain.setValueAtTime(baseVolume * 0.8 * variation, now);
                    blastGain.gain.exponentialRampToValueAtTime(0.01, now + 0.04);

                    blastOsc.start(now);
                    blastOsc.stop(now + 0.04);

                    // Layer 3: Low-end thump (pressure wave)
                    const thumpOsc = this.audioContext.createOscillator();
                    const thumpGain = this.audioContext.createGain();

                    thumpOsc.type = 'sine';
                    thumpOsc.frequency.setValueAtTime(45 * pitchVar, now);
                    thumpOsc.frequency.exponentialRampToValueAtTime(20, now + 0.06);

                    thumpOsc.connect(thumpGain);
                    thumpGain.connect(this.audioContext.destination);

                    thumpGain.gain.setValueAtTime(baseVolume * 0.7 * variation, now);
                    thumpGain.gain.exponentialRampToValueAtTime(0.01, now + 0.06);

                    thumpOsc.start(now);
                    thumpOsc.stop(now + 0.06);

                    // Layer 4: Mechanical action (slide/ejection)
                    const actionBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.01, this.audioContext.sampleRate);
                    const actionData = actionBuffer.getChannelData(0);

                    for (let i = 0; i < actionData.length; i++) {
                        actionData[i] = (Math.random() * 2 - 1) * (1 - i / actionData.length);
                    }

                    const actionSource = this.audioContext.createBufferSource();
                    const actionGain = this.audioContext.createGain();
                    const actionFilter = this.audioContext.createBiquadFilter();

                    actionSource.buffer = actionBuffer;
                    actionFilter.type = 'bandpass';
                    actionFilter.frequency.setValueAtTime(1200 * pitchVar, now + 0.015);
                    actionFilter.Q.setValueAtTime(4, now + 0.015);

                    actionSource.connect(actionFilter);
                    actionFilter.connect(actionGain);
                    actionGain.connect(this.audioContext.destination);

                    actionGain.gain.setValueAtTime(baseVolume * 0.3 * variation, now + 0.015);
                    actionGain.gain.exponentialRampToValueAtTime(0.01, now + 0.025);

                    actionSource.start(now + 0.015);
                };
            }

            createExplosionSound(frequency, duration) {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    // Create noise for explosion
                    const bufferSize = this.audioContext.sampleRate * duration;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const output = buffer.getChannelData(0);

                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }

                    const noiseSource = this.audioContext.createBufferSource();
                    const filterNode = this.audioContext.createBiquadFilter();
                    const gainNode = this.audioContext.createGain();

                    noiseSource.buffer = buffer;
                    noiseSource.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);

                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    filterNode.frequency.exponentialRampToValueAtTime(frequency * 0.1, this.audioContext.currentTime + duration);

                    gainNode.gain.setValueAtTime(this.sfxVolume * this.masterVolume * 0.5, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);

                    noiseSource.start(this.audioContext.currentTime);
                    noiseSource.stop(this.audioContext.currentTime + duration);
                };
            }

            createFragGrenadeSound() {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    // Create a shorter, more aggressive explosion sound for frag grenade
                    const duration = 0.2;
                    const bufferSize = this.audioContext.sampleRate * duration;
                    const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const output = buffer.getChannelData(0);

                    // Mix noise with a sharp attack
                    for (let i = 0; i < bufferSize; i++) {
                        const noise = Math.random() * 2 - 1;
                        const envelope = 1 - (i / bufferSize); // Quick decay
                        output[i] = noise * envelope;
                    }

                    const noiseSource = this.audioContext.createBufferSource();
                    const filterNode = this.audioContext.createBiquadFilter();
                    const gainNode = this.audioContext.createGain();

                    noiseSource.buffer = buffer;
                    noiseSource.connect(filterNode);
                    filterNode.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);

                    filterNode.type = 'highpass';
                    filterNode.frequency.setValueAtTime(300, this.audioContext.currentTime);

                    gainNode.gain.setValueAtTime(this.sfxVolume * this.masterVolume * 0.4, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);

                    noiseSource.start(this.audioContext.currentTime);
                    noiseSource.stop(this.audioContext.currentTime + duration);
                };
            }

            createMissileSound() {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);

                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(100, this.audioContext.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(200, this.audioContext.currentTime + 0.3);

                    gainNode.gain.setValueAtTime(this.sfxVolume * this.masterVolume * 0.2, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);

                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.3);
                };
            }

            createDeathSound() {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);

                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(400, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, this.audioContext.currentTime + 0.2);

                    gainNode.gain.setValueAtTime(this.sfxVolume * this.masterVolume * 0.15, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);

                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.2);
                };
            }

            createHitSound() {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);

                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(800, this.audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, this.audioContext.currentTime + 0.1);

                    gainNode.gain.setValueAtTime(this.sfxVolume * this.masterVolume * 0.4, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.1);

                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.1);
                };
            }

            createPickupSound() {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);

                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(523, this.audioContext.currentTime);
                    oscillator.frequency.setValueAtTime(659, this.audioContext.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(784, this.audioContext.currentTime + 0.2);

                    gainNode.gain.setValueAtTime(this.sfxVolume * this.masterVolume * 0.3, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);

                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.3);
                };
            }

            createClickSound() {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);

                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(1000, this.audioContext.currentTime);

                    gainNode.gain.setValueAtTime(this.sfxVolume * this.masterVolume * 0.1, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.05);

                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + 0.05);
                };
            }

            createDoorSound() {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    const duration = 0.4; // Longer for more realistic whoosh
                    const now = this.audioContext.currentTime;

                    // Main whoosh sound (filtered noise)
                    const bufferSize = this.audioContext.sampleRate * duration;
                    const noiseBuffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
                    const noiseData = noiseBuffer.getChannelData(0);

                    // Generate filtered white noise for air movement
                    for (let i = 0; i < bufferSize; i++) {
                        noiseData[i] = (Math.random() * 2 - 1) * 0.3;
                    }

                    const noiseSource = this.audioContext.createBufferSource();
                    noiseSource.buffer = noiseBuffer;

                    // Filter to shape the whoosh - smoother sweep
                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(400, now);
                    filter.frequency.exponentialRampToValueAtTime(150, now + duration);
                    filter.Q.setValueAtTime(0.7, now); // Lower Q for softer filtering

                    // Main gain envelope for whoosh - gentler transitions
                    const whooshGain = this.audioContext.createGain();
                    whooshGain.gain.setValueAtTime(0, now);
                    whooshGain.gain.exponentialRampToValueAtTime(this.sfxVolume * this.masterVolume * 0.35, now + 0.1);
                    whooshGain.gain.exponentialRampToValueAtTime(this.sfxVolume * this.masterVolume * 0.25, now + 0.25);
                    whooshGain.gain.exponentialRampToValueAtTime(0.001, now + duration);

                    // Softer mechanical sound at start
                    const clickOsc = this.audioContext.createOscillator();
                    const clickGain = this.audioContext.createGain();
                    clickOsc.type = 'triangle'; // Softer than square wave
                    clickOsc.frequency.setValueAtTime(120, now);
                    clickGain.gain.setValueAtTime(this.sfxVolume * this.masterVolume * 0.12, now);
                    clickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);

                    // Connect the audio graph
                    noiseSource.connect(filter);
                    filter.connect(whooshGain);
                    whooshGain.connect(this.audioContext.destination);

                    clickOsc.connect(clickGain);
                    clickGain.connect(this.audioContext.destination);

                    // Start the sounds
                    noiseSource.start(now);
                    noiseSource.stop(now + duration);
                    clickOsc.start(now);
                    clickOsc.stop(now + 0.05);
                };
            }

            createAxeChopSound() {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    const now = this.audioContext.currentTime;
                    const baseVolume = this.sfxVolume * this.masterVolume * 0.8;

                    // Layer 1: Initial impact - sharp crack
                    const impactOsc = this.audioContext.createOscillator();
                    const impactGain = this.audioContext.createGain();
                    const impactFilter = this.audioContext.createBiquadFilter();

                    impactOsc.type = 'square';
                    impactOsc.frequency.setValueAtTime(800, now);
                    impactOsc.frequency.exponentialRampToValueAtTime(200, now + 0.02);

                    impactFilter.type = 'highpass';
                    impactFilter.frequency.setValueAtTime(400, now);

                    impactOsc.connect(impactFilter);
                    impactFilter.connect(impactGain);
                    impactGain.connect(this.audioContext.destination);

                    impactGain.gain.setValueAtTime(baseVolume * 0.6, now);
                    impactGain.gain.exponentialRampToValueAtTime(0.01, now + 0.02);

                    impactOsc.start(now);
                    impactOsc.stop(now + 0.02);

                    // Layer 2: Wood splitting/cracking sound
                    const crackBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.15, this.audioContext.sampleRate);
                    const crackData = crackBuffer.getChannelData(0);

                    for (let i = 0; i < crackData.length; i++) {
                        const decay = Math.pow(1 - i / crackData.length, 2);
                        // Create cracking/splitting texture
                        const crack = Math.random() > 0.8 ? (Math.random() * 2 - 1) * 1.5 : (Math.random() * 2 - 1) * 0.2;
                        crackData[i] = crack * decay;
                    }

                    const crackSource = this.audioContext.createBufferSource();
                    const crackGain = this.audioContext.createGain();
                    const crackFilter = this.audioContext.createBiquadFilter();

                    crackSource.buffer = crackBuffer;
                    crackFilter.type = 'bandpass';
                    crackFilter.frequency.setValueAtTime(600, now + 0.01);
                    crackFilter.Q.setValueAtTime(2, now + 0.01);

                    crackSource.connect(crackFilter);
                    crackFilter.connect(crackGain);
                    crackGain.connect(this.audioContext.destination);

                    crackGain.gain.setValueAtTime(baseVolume * 0.7, now + 0.01);
                    crackGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                    crackSource.start(now + 0.01);

                    // Layer 3: Dull thud as axe bites into wood
                    const thudOsc = this.audioContext.createOscillator();
                    const thudGain = this.audioContext.createGain();
                    const thudFilter = this.audioContext.createBiquadFilter();

                    thudOsc.type = 'sine';
                    thudOsc.frequency.setValueAtTime(120, now + 0.005);
                    thudOsc.frequency.exponentialRampToValueAtTime(60, now + 0.1);

                    thudFilter.type = 'lowpass';
                    thudFilter.frequency.setValueAtTime(250, now + 0.005);

                    thudOsc.connect(thudFilter);
                    thudFilter.connect(thudGain);
                    thudGain.connect(this.audioContext.destination);

                    thudGain.gain.setValueAtTime(baseVolume * 0.5, now + 0.005);
                    thudGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);

                    thudOsc.start(now + 0.005);
                    thudOsc.stop(now + 0.1);
                };
            }

            playSound(soundName) {
                if (this.sounds[soundName]) {
                    this.sounds[soundName]();
                }
            }

            startBackgroundMusic() {
                if (!this.enabled || !this.audioContext) return;

                // Option 1: Spooky Horror Ambient
                this.createSpookyAmbient();

                // Option 2: Dark Electronic Pulse (uncomment to try)
                // this.createDarkPulse();

                // Option 3: Tense Action Music (uncomment to try)
                // this.createActionMusic();

                // Option 4: Silent (no music)
                // this.currentMusic = null;
            }

            createSpookyAmbient() {
                // Create a spooky, horror-game style ambient track
                const lowDrone = this.audioContext.createOscillator();
                const midTone = this.audioContext.createOscillator();
                const filter = this.audioContext.createBiquadFilter();
                const gainNode = this.audioContext.createGain();

                lowDrone.connect(filter);
                midTone.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                lowDrone.type = 'sawtooth';
                midTone.type = 'triangle';
                lowDrone.frequency.setValueAtTime(55, this.audioContext.currentTime); // Low A
                midTone.frequency.setValueAtTime(82.5, this.audioContext.currentTime); // E

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, this.audioContext.currentTime);
                filter.Q.setValueAtTime(5, this.audioContext.currentTime);

                gainNode.gain.setValueAtTime(this.musicVolume * this.masterVolume * 0.03, this.audioContext.currentTime);

                lowDrone.start();
                midTone.start();

                this.currentMusic = { lowDrone, midTone, gainNode };
            }

            createDarkPulse() {
                // Pulsing electronic dark music
                const bass = this.audioContext.createOscillator();
                const pulse = this.audioContext.createOscillator();
                const bassGain = this.audioContext.createGain();
                const pulseGain = this.audioContext.createGain();
                const mainGain = this.audioContext.createGain();

                bass.connect(bassGain);
                pulse.connect(pulseGain);
                bassGain.connect(mainGain);
                pulseGain.connect(mainGain);
                mainGain.connect(this.audioContext.destination);

                bass.type = 'square';
                pulse.type = 'triangle';
                bass.frequency.setValueAtTime(65, this.audioContext.currentTime); // Low C
                pulse.frequency.setValueAtTime(130, this.audioContext.currentTime); // High C

                // Create pulsing effect
                const now = this.audioContext.currentTime;
                pulseGain.gain.setValueAtTime(0, now);
                for (let i = 0; i < 60; i++) { // 60 seconds of pulses
                    const time = now + i * 0.5; // Every 500ms
                    pulseGain.gain.setValueAtTime(0, time);
                    pulseGain.gain.linearRampToValueAtTime(0.1, time + 0.1);
                    pulseGain.gain.linearRampToValueAtTime(0, time + 0.3);
                }

                bassGain.gain.setValueAtTime(this.musicVolume * this.masterVolume * 0.02, this.audioContext.currentTime);
                mainGain.gain.setValueAtTime(1, this.audioContext.currentTime);

                bass.start();
                pulse.start();

                this.currentMusic = { bass, pulse, bassGain, pulseGain, mainGain };
            }

            createActionMusic() {
                // Fast-paced action music
                const bass = this.audioContext.createOscillator();
                const melody = this.audioContext.createOscillator();
                const filter = this.audioContext.createBiquadFilter();
                const gainNode = this.audioContext.createGain();

                bass.connect(gainNode);
                melody.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                bass.type = 'square';
                melody.type = 'sawtooth';

                // Simple bassline pattern
                bass.frequency.setValueAtTime(110, this.audioContext.currentTime);

                // Melody with some variation
                melody.frequency.setValueAtTime(220, this.audioContext.currentTime);
                melody.frequency.setValueAtTime(330, this.audioContext.currentTime + 0.5);
                melody.frequency.setValueAtTime(275, this.audioContext.currentTime + 1.0);
                melody.frequency.setValueAtTime(220, this.audioContext.currentTime + 1.5);

                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(800, this.audioContext.currentTime);

                gainNode.gain.setValueAtTime(this.musicVolume * this.masterVolume * 0.04, this.audioContext.currentTime);

                bass.start();
                melody.start();

                this.currentMusic = { bass, melody, gainNode };
            }

            stopBackgroundMusic() {
                if (this.currentMusic) {
                    // Stop all oscillators in the current music object
                    Object.keys(this.currentMusic).forEach(key => {
                        if (this.currentMusic[key] && typeof this.currentMusic[key].stop === 'function') {
                            try {
                                this.currentMusic[key].stop();
                            } catch (e) {
                                // Ignore errors if oscillator already stopped
                            }
                        }
                    });
                    this.currentMusic = null;
                }
            }

            createZombieDeathSound() {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    const now = this.audioContext.currentTime;
                    const baseVolume = this.sfxVolume * this.masterVolume * 0.6;
                    const variation = 0.9 + Math.random() * 0.2;

                    // Layer 1: Bullet piercing flesh - wet, squelching sound
                    const piercingBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.04, this.audioContext.sampleRate);
                    const piercingData = piercingBuffer.getChannelData(0);
                    for (let i = 0; i < piercingData.length; i++) {
                        const decay = Math.pow(1 - i / piercingData.length, 3);
                        piercingData[i] = (Math.random() * 2 - 1) * decay * (1 + Math.sin(i * 0.05) * 0.4);
                    }

                    const piercingSource = this.audioContext.createBufferSource();
                    const piercingGain = this.audioContext.createGain();
                    const piercingFilter = this.audioContext.createBiquadFilter();

                    piercingSource.buffer = piercingBuffer;
                    piercingFilter.type = 'lowpass';
                    piercingFilter.frequency.setValueAtTime(600, now);
                    piercingFilter.frequency.exponentialRampToValueAtTime(200, now + 0.04);

                    piercingSource.connect(piercingFilter);
                    piercingFilter.connect(piercingGain);
                    piercingGain.connect(this.audioContext.destination);

                    piercingGain.gain.setValueAtTime(baseVolume * 0.8 * variation, now);
                    piercingGain.gain.exponentialRampToValueAtTime(0.01, now + 0.04);
                    piercingSource.start(now);

                    // Layer 2: Zombie groan/death rattle
                    const groanOsc = this.audioContext.createOscillator();
                    const groanGain = this.audioContext.createGain();
                    const groanFilter = this.audioContext.createBiquadFilter();

                    groanOsc.type = 'sawtooth';
                    groanOsc.frequency.setValueAtTime(80 + Math.random() * 40, now + 0.02);
                    groanOsc.frequency.exponentialRampToValueAtTime(40, now + 0.2);

                    groanFilter.type = 'lowpass';
                    groanFilter.frequency.setValueAtTime(300, now + 0.02);

                    groanOsc.connect(groanFilter);
                    groanFilter.connect(groanGain);
                    groanGain.connect(this.audioContext.destination);

                    groanGain.gain.setValueAtTime(baseVolume * 0.5 * variation, now + 0.02);
                    groanGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

                    groanOsc.start(now + 0.02);
                    groanOsc.stop(now + 0.2);

                    // Layer 3: Body thud
                    const thudOsc = this.audioContext.createOscillator();
                    const thudGain = this.audioContext.createGain();

                    thudOsc.type = 'sine';
                    thudOsc.frequency.setValueAtTime(60, now + 0.1);
                    thudOsc.frequency.exponentialRampToValueAtTime(30, now + 0.15);

                    thudOsc.connect(thudGain);
                    thudGain.connect(this.audioContext.destination);

                    thudGain.gain.setValueAtTime(baseVolume * 0.6 * variation, now + 0.1);
                    thudGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

                    thudOsc.start(now + 0.1);
                    thudOsc.stop(now + 0.15);
                };
            }

            createSkeletonDeathSound() {
                return () => {
                    if (!this.enabled || !this.audioContext) return;

                    const now = this.audioContext.currentTime;
                    const baseVolume = this.sfxVolume * this.masterVolume * 0.7;
                    const variation = 0.9 + Math.random() * 0.2;

                    // Layer 1: Bones cracking
                    const crackBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.08, this.audioContext.sampleRate);
                    const crackData = crackBuffer.getChannelData(0);
                    for (let i = 0; i < crackData.length; i++) {
                        const decay = 1 - (i / crackData.length) * 0.7;
                        const crack = Math.random() > 0.7 ? (Math.random() * 2 - 1) * 2 : (Math.random() * 2 - 1) * 0.3;
                        crackData[i] = crack * decay;
                    }

                    const crackSource = this.audioContext.createBufferSource();
                    const crackGain = this.audioContext.createGain();
                    const crackFilter = this.audioContext.createBiquadFilter();

                    crackSource.buffer = crackBuffer;
                    crackFilter.type = 'highpass';
                    crackFilter.frequency.setValueAtTime(800, now);
                    crackFilter.Q.setValueAtTime(2, now);

                    crackSource.connect(crackFilter);
                    crackFilter.connect(crackGain);
                    crackGain.connect(this.audioContext.destination);

                    crackGain.gain.setValueAtTime(baseVolume * 1.0 * variation, now);
                    crackGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
                    crackSource.start(now);

                    // Layer 2: Multiple bone snaps
                    for (let i = 0; i < 3; i++) {
                        const snapOsc = this.audioContext.createOscillator();
                        const snapGain = this.audioContext.createGain();
                        const snapFilter = this.audioContext.createBiquadFilter();

                        const startTime = now + (i * 0.02) + Math.random() * 0.01;

                        snapOsc.type = 'square';
                        snapOsc.frequency.setValueAtTime(1200 + Math.random() * 800, startTime);
                        snapOsc.frequency.exponentialRampToValueAtTime(400, startTime + 0.015);

                        snapFilter.type = 'bandpass';
                        snapFilter.frequency.setValueAtTime(1500, startTime);
                        snapFilter.Q.setValueAtTime(4, startTime);

                        snapOsc.connect(snapFilter);
                        snapFilter.connect(snapGain);
                        snapGain.connect(this.audioContext.destination);

                        snapGain.gain.setValueAtTime(baseVolume * 0.4 * variation, startTime);
                        snapGain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.015);

                        snapOsc.start(startTime);
                        snapOsc.stop(startTime + 0.015);
                    }

                    // Layer 3: Bones clattering
                    const clatterBuffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 0.12, this.audioContext.sampleRate);
                    const clatterData = clatterBuffer.getChannelData(0);
                    for (let i = 0; i < clatterData.length; i++) {
                        const decay = Math.pow(1 - i / clatterData.length, 1.5);
                        clatterData[i] = (Math.random() * 2 - 1) * decay * (Math.random() > 0.6 ? 1 : 0.3);
                    }

                    const clatterSource = this.audioContext.createBufferSource();
                    const clatterGain = this.audioContext.createGain();
                    const clatterFilter = this.audioContext.createBiquadFilter();

                    clatterSource.buffer = clatterBuffer;
                    clatterFilter.type = 'bandpass';
                    clatterFilter.frequency.setValueAtTime(1000, now + 0.05);
                    clatterFilter.Q.setValueAtTime(1.5, now + 0.05);

                    clatterSource.connect(clatterFilter);
                    clatterFilter.connect(clatterGain);
                    clatterGain.connect(this.audioContext.destination);

                    clatterGain.gain.setValueAtTime(baseVolume * 0.6 * variation, now + 0.05);
                    clatterGain.gain.exponentialRampToValueAtTime(0.01, now + 0.17);
                    clatterSource.start(now + 0.05);
                };
            }
        }

        const audioManager = new AudioManager();

        // Mobile detection and accelerometer setup

        async function requestMotionPermission() {
            // Lock screen orientation to portrait
            if (screen.orientation && screen.orientation.lock) {
                try {
                    await screen.orientation.lock('portrait');
                } catch (error) {
                    console.warn('Could not lock orientation:', error);
                }
            }

            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    motionPermissionGranted = permission === 'granted';
                } catch (error) {
                    console.warn('Motion permission request failed:', error);
                    motionPermissionGranted = false;
                }
            } else {
                // For Android or browsers that don't need permission
                motionPermissionGranted = true;
            }

            if (motionPermissionGranted) {
                setupAccelerometer();
            }
        }

        function setupAccelerometer() {
            window.addEventListener('deviceorientation', (event) => {
                if (motionPermissionGranted && isMobile) {
                    // Get orientation data (beta = front-back tilt, gamma = left-right tilt)
                    accelerometerData.x = event.gamma || 0; // Left-right tilt (-90 to 90)
                    accelerometerData.y = event.beta || 0;  // Front-back tilt (-180 to 180)
                    accelerometerData.z = event.alpha || 0; // Compass direction
                }
            });
        }

        // Mobile detection already done above

        // Update instructions for mobile users
        if (isMobile) {
            const movementInstructions = document.getElementById('movement-instructions');
            const instructions = document.getElementById('instructions');
            const weaponTrigger = document.getElementById('weapon-drawer-trigger');
            const weaponDrawer = document.getElementById('weapon-drawer');

            if (movementInstructions) {
                movementInstructions.textContent = 'Tilt your device to move';
            }
            if (instructions) {
                const shootInstructions = instructions.children[1]; // Second paragraph about shooting
                if (shootInstructions) {
                    shootInstructions.textContent = 'Tap screen to shoot, tap ⚔️ to change weapons';
                }
            }

            // Show mobile weapon drawer elements
            if (weaponTrigger) {
                weaponTrigger.style.display = 'flex';
            }
            if (weaponDrawer) {
                weaponDrawer.style.display = 'flex';
            }
        }

        // Mobile weapon drawer functionality
        const weaponTrigger = document.getElementById('weapon-drawer-trigger');
        const weaponDrawer = document.getElementById('weapon-drawer');
        let isDrawerOpen = false;

        function toggleWeaponDrawer() {
            isDrawerOpen = !isDrawerOpen;
            if (isDrawerOpen) {
                weaponDrawer?.classList.add('open');
            } else {
                weaponDrawer?.classList.remove('open');
            }
        }

        function closeWeaponDrawer() {
            isDrawerOpen = false;
            weaponDrawer?.classList.remove('open');
        }

        function updateWeaponButtons() {
            const buttons = document.querySelectorAll('.weapon-btn');
            buttons.forEach(btn => {
                btn.classList.toggle('active', btn.dataset.weapon === currentWeapon);
            });

            // Update trigger button to show current weapon
            if (weaponTrigger && currentWeapon) {
                const weaponIcons = {
                    pistol: '🔫',
                    shotgun: '🔫',
                    fragGrenade: '💣',
                    nuke: '☢️',
                    missile: '🚀'
                };
                weaponTrigger.textContent = weaponIcons[currentWeapon] || '⚔️';
            }
        }

        // Add click handlers for weapon drawer
        weaponTrigger?.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            toggleWeaponDrawer();
            audioManager.playSound('buttonClick');
        });

        // Add click handlers for weapon buttons
        document.querySelectorAll('.weapon-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                currentWeapon = btn.dataset.weapon;
                updateWeaponDisplay();
                updateAmmoDisplay();
                updateWeaponButtons();
                audioManager.playSound('buttonClick');

                // Close drawer after selection
                closeWeaponDrawer();
            });
        });

        // Close drawer when clicking outside of it
        if (isMobile) {
            canvas.addEventListener('touchstart', () => {
                if (isDrawerOpen) {
                    closeWeaponDrawer();
                }
            });
        }

        // Define the walls of the maze
        let walls = [];
        let doors = [];
        const baseSize = 137.5; // Increased by 10% (125 * 1.1)
        const doorSize = 64; // Grid-aligned: 1 * GRID_SIZE
        const wallThickness = 16; // Grid-aligned: GRID_SIZE/4
        const doorThickness = 12; // Thinner than wall thickness for realistic sliding
        
        function createWalls() {
            const w = canvas.width;
            const h = canvas.height;
            const wallColor = '#b0b0b0'; 
            const doorColor = '#8c8c8c';
            
            const centerX = 0; // Position building at world center (0,0 should be grid center)
            const centerY = 0;
            const size = 192; // Grid-aligned: 3 * GRID_SIZE (64) = 192 units
            const wallHalfSize = size / 2;
            const doorOffset = 40;
            const topDoorX = centerX - doorSize / 2;
            const topDoorY = centerY - wallHalfSize;
            const bottomDoorX = centerX - doorSize / 2;
            const bottomDoorY = centerY + wallHalfSize - wallThickness;

            walls = [
                // Top walls with door gap
                { x: centerX - wallHalfSize, y: centerY - wallHalfSize, width: (size - doorSize) / 2, height: wallThickness, color: wallColor },
                { x: centerX + doorSize / 2, y: centerY - wallHalfSize, width: (size - doorSize) / 2, height: wallThickness, color: wallColor },
                
                // Bottom wall with door gap
                { x: centerX - wallHalfSize, y: centerY + wallHalfSize - wallThickness, width: (size - doorSize) / 2, height: wallThickness, color: wallColor },
                { x: centerX + doorSize / 2, y: centerY + wallHalfSize - wallThickness, width: (size - doorSize) / 2, height: wallThickness, color: wallColor },
                
                // Left wall
                { x: centerX - wallHalfSize, y: centerY - wallHalfSize, width: wallThickness, height: size, color: wallColor },
                
                // Right wall
                { x: centerX + wallHalfSize - wallThickness, y: centerY - wallHalfSize, width: wallThickness, height: size, color: wallColor },
            ];

            // Define the two doors with animation properties
            // Center doors within wall thickness for realistic appearance
            const doorYOffset = (wallThickness - doorThickness) / 2;
            doors = [
                {
                    x: topDoorX, y: topDoorY + doorYOffset, width: doorSize, height: doorThickness,
                    color: doorColor, open: false, openAmount: 0, targetOpen: 0
                },
                {
                    x: bottomDoorX, y: bottomDoorY + doorYOffset, width: doorSize, height: doorThickness,
                    color: doorColor, open: false, openAmount: 0, targetOpen: 0
                }
            ];
        }

        window.addEventListener('resize', resizeCanvas);

        // Gamepad event listeners
        window.addEventListener("gamepadconnected", function(e) {
            console.log("Gamepad connected:", e.gamepad.id);
            gamepad = e.gamepad;
            gamepadIndex = e.gamepad.index;
        });

        window.addEventListener("gamepaddisconnected", function(e) {
            console.log("Gamepad disconnected:", e.gamepad.id);
            if (e.gamepad.index === gamepadIndex) {
                disconnectGamepad();
            }
        });

        // Global grid system constants
        const GRID_SIZE = 64; // Match tile size for consistency
        const OBJECT_GRID_SIZE = 128; // Larger grid for environmental objects

        // Enhanced Grid System
        const GridSystem = {
            // Snap coordinates to grid centers (accounting for grid offset)
            snapToGrid: function(x, y, gridSize = GRID_SIZE) {
                // Snap to grid centers (multiples of gridSize: 0, 64, 128, 192, 256...)
                return {
                    x: Math.round(x / gridSize) * gridSize,
                    y: Math.round(y / gridSize) * gridSize
                };
            },

            // Get grid coordinates from world coordinates
            worldToGrid: function(x, y, gridSize = GRID_SIZE) {
                return {
                    gridX: Math.floor((x + gridSize/2) / gridSize),
                    gridY: Math.floor((y + gridSize/2) / gridSize)
                };
            },

            // Get world coordinates from grid coordinates
            gridToWorld: function(gridX, gridY, gridSize = GRID_SIZE) {
                return {
                    x: gridX * gridSize,
                    y: gridY * gridSize
                };
            },

            // Check if a grid cell is occupied
            isGridCellOccupied: function(gridX, gridY, occupiedCells = new Set()) {
                return occupiedCells.has(`${gridX},${gridY}`);
            },

            // Find nearest empty grid cell
            findNearestEmptyCell: function(x, y, occupiedCells = new Set(), gridSize = GRID_SIZE, maxRadius = 5) {
                const startGrid = this.worldToGrid(x, y, gridSize);

                // Check center first
                if (!this.isGridCellOccupied(startGrid.gridX, startGrid.gridY, occupiedCells)) {
                    return this.gridToWorld(startGrid.gridX, startGrid.gridY, gridSize);
                }

                // Spiral search outward
                for (let radius = 1; radius <= maxRadius; radius++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        for (let dy = -radius; dy <= radius; dy++) {
                            if (Math.abs(dx) === radius || Math.abs(dy) === radius) {
                                const testX = startGrid.gridX + dx;
                                const testY = startGrid.gridY + dy;
                                if (!this.isGridCellOccupied(testX, testY, occupiedCells)) {
                                    return this.gridToWorld(testX, testY, gridSize);
                                }
                            }
                        }
                    }
                }
                return null; // No empty cell found
            },

            // Create aligned rectangle (for buildings, walls, etc.)
            createAlignedRect: function(centerX, centerY, width, height, gridSize = GRID_SIZE) {
                const snapped = this.snapToGrid(centerX, centerY, gridSize);
                return {
                    x: snapped.x - width/2,
                    y: snapped.y - height/2,
                    width: width,
                    height: height,
                    centerX: snapped.x,
                    centerY: snapped.y
                };
            }
        };

        // Structure Generation System
        const StructureGenerator = {
            // Create a simple rectangular building
            createBuilding: function(centerX, centerY, widthCells, heightCells, options = {}) {
                const {
                    wallThickness = 16,
                    doorWidth = 64,
                    doorSides = ['top'], // 'top', 'bottom', 'left', 'right'
                    wallColor = '#b0b0b0',
                    doorColor = '#8c8c8c'
                } = options;

                const width = widthCells * GRID_SIZE;
                const height = heightCells * GRID_SIZE;
                const rect = GridSystem.createAlignedRect(centerX, centerY, width, height);

                const walls = [];
                const doors = [];

                // Create walls with door gaps
                doorSides.forEach(side => {
                    const doorOffset = (width - doorWidth) / 2;

                    switch(side) {
                        case 'top':
                            // Top wall with door gap
                            walls.push({
                                x: rect.x, y: rect.y,
                                width: doorOffset, height: wallThickness,
                                color: wallColor
                            });
                            walls.push({
                                x: rect.x + doorOffset + doorWidth, y: rect.y,
                                width: doorOffset, height: wallThickness,
                                color: wallColor
                            });
                            doors.push({
                                x: rect.x + doorOffset, y: rect.y + (wallThickness - 12) / 2,
                                width: doorWidth, height: 12,
                                color: doorColor, open: false, openAmount: 0, targetOpen: 0
                            });
                            break;

                        case 'bottom':
                            // Bottom wall with door gap
                            walls.push({
                                x: rect.x, y: rect.y + height - wallThickness,
                                width: doorOffset, height: wallThickness,
                                color: wallColor
                            });
                            walls.push({
                                x: rect.x + doorOffset + doorWidth, y: rect.y + height - wallThickness,
                                width: doorOffset, height: wallThickness,
                                color: wallColor
                            });
                            doors.push({
                                x: rect.x + doorOffset, y: rect.y + height - wallThickness + (wallThickness - 12) / 2,
                                width: doorWidth, height: 12,
                                color: doorColor, open: false, openAmount: 0, targetOpen: 0
                            });
                            break;
                    }
                });

                // Always add left and right walls (full height)
                walls.push({
                    x: rect.x, y: rect.y,
                    width: wallThickness, height: height,
                    color: wallColor
                });
                walls.push({
                    x: rect.x + width - wallThickness, y: rect.y,
                    width: wallThickness, height: height,
                    color: wallColor
                });

                return { walls, doors, bounds: rect };
            },

            // Create a defensive wall segment
            createWallSegment: function(startX, startY, endX, endY, thickness = 32) {
                const startSnapped = GridSystem.snapToGrid(startX, startY);
                const endSnapped = GridSystem.snapToGrid(endX, endY);

                const dx = endSnapped.x - startSnapped.x;
                const dy = endSnapped.y - startSnapped.y;
                const length = Math.sqrt(dx * dx + dy * dy);

                if (length === 0) return [];

                // Create wall segments only at grid centers along the line
                const segments = [];

                // Determine if this is horizontal or vertical wall
                const isHorizontal = Math.abs(dx) > Math.abs(dy);

                if (isHorizontal) {
                    // Horizontal wall - place segments at grid centers along X axis
                    const y = startSnapped.y;
                    const startX = Math.min(startSnapped.x, endSnapped.x);
                    const endX = Math.max(startSnapped.x, endSnapped.x);

                    for (let x = startX; x <= endX; x += GRID_SIZE) {
                        segments.push({
                            x: x - thickness/2,
                            y: y - thickness/2,
                            width: thickness,
                            height: thickness,
                            color: '#999999'
                        });
                    }
                } else {
                    // Vertical wall - place segments at grid centers along Y axis
                    const x = startSnapped.x;
                    const startY = Math.min(startSnapped.y, endSnapped.y);
                    const endY = Math.max(startSnapped.y, endSnapped.y);

                    for (let y = startY; y <= endY; y += GRID_SIZE) {
                        segments.push({
                            x: x - thickness/2,
                            y: y - thickness/2,
                            width: thickness,
                            height: thickness,
                            color: '#999999'
                        });
                    }
                }

                return segments;
            },

            // Create a watchtower
            createWatchtower: function(centerX, centerY) {
                const baseSize = GRID_SIZE * 2; // 2x2 grid cells
                const towerHeight = GRID_SIZE * 3; // 3 cells high

                const base = GridSystem.createAlignedRect(centerX, centerY, baseSize, baseSize);
                const walls = [];

                // Base walls
                walls.push({
                    x: base.x, y: base.y,
                    width: baseSize, height: 16,
                    color: '#8B4513' // Brown
                });
                walls.push({
                    x: base.x, y: base.y + baseSize - 16,
                    width: baseSize, height: 16,
                    color: '#8B4513'
                });
                walls.push({
                    x: base.x, y: base.y,
                    width: 16, height: baseSize,
                    color: '#8B4513'
                });
                walls.push({
                    x: base.x + baseSize - 16, y: base.y,
                    width: 16, height: baseSize,
                    color: '#8B4513'
                });

                // Tower structure (visual indicator - could be enhanced)
                walls.push({
                    x: base.centerX - 8, y: base.centerY - towerHeight/2,
                    width: 16, height: towerHeight,
                    color: '#654321' // Darker brown for tower
                });

                return { walls, bounds: base };
            },

            // Create a procedural tree with seeded randomness
            createTree: function(gridX, gridY, seed = null, type = 'oak', size = 'medium') {
                // Use position-based seed if none provided
                if (seed === null) {
                    seed = Math.abs((gridX * 73 + gridY * 37) % 1000);
                }

                // Seeded random number generator
                function seededRandom(s) {
                    s = Math.sin(s) * 10000;
                    return s - Math.floor(s);
                }

                const worldPos = GridSystem.gridToWorld(gridX, gridY);
                const centerX = worldPos.x;
                const centerY = worldPos.y;

                // Tree parameters based on type and size
                const treeConfig = {
                    oak: {
                        small: { trunkWidth: 8, trunkHeight: 24, canopySize: 32 },
                        medium: { trunkWidth: 12, trunkHeight: 36, canopySize: 48 },
                        large: { trunkWidth: 16, trunkHeight: 48, canopySize: 64 }
                    }
                };

                const config = treeConfig[type][size];

                // Add some seeded variation (±20%)
                const trunkHeight = config.trunkHeight * (0.8 + seededRandom(seed + 1) * 0.4);
                const canopySize = config.canopySize * (0.8 + seededRandom(seed + 2) * 0.4);
                const trunkWidth = config.trunkWidth * (0.8 + seededRandom(seed + 3) * 0.4);

                // Create tree collision data (separate from walls)
                const collision = {
                    x: centerX - trunkWidth/2,
                    y: centerY - trunkHeight/2,
                    width: trunkWidth,
                    height: trunkHeight,
                    centerX: centerX,
                    centerY: centerY,
                    radius: trunkWidth/2, // For circular collision if needed
                    health: 100, // Trees can be damaged
                    maxHealth: 100,
                    type: 'tree'
                };

                // Store visual data for rendering (non-collision)
                const visualData = {
                    centerX: centerX,
                    centerY: centerY,
                    trunkWidth: trunkWidth,
                    trunkHeight: trunkHeight,
                    canopySize: canopySize,
                    canopyY: centerY, // Canopy centered on grid position (top-down view)
                    foliageColor: '#228B22', // Forest green
                    seed: seed
                };

                return {
                    collision: collision,
                    visual: visualData,
                    bounds: {
                        x: centerX - canopySize/2,
                        y: centerY - trunkHeight/2,
                        width: canopySize,
                        height: trunkHeight + canopySize/2,
                        centerX: centerX,
                        centerY: centerY
                    }
                };
            },

            // Create a procedural rock with seeded randomness
            createRock: function(gridX, gridY, seed = null, type = 'granite', size = 'medium') {
                // Use position-based seed if none provided
                if (seed === null) {
                    seed = Math.abs((gridX * 47 + gridY * 53) % 1000);
                }

                // Seeded random number generator
                function seededRandom(s) {
                    s = Math.sin(s) * 10000;
                    return s - Math.floor(s);
                }

                const worldPos = GridSystem.gridToWorld(gridX, gridY);
                const centerX = worldPos.x;
                const centerY = worldPos.y;

                // Rock parameters based on type and size
                const rockConfig = {
                    granite: {
                        small: { width: 20, height: 16 },
                        medium: { width: 32, height: 24 },
                        large: { width: 48, height: 36 }
                    },
                    boulder: {
                        small: { width: 28, height: 24 },
                        medium: { width: 44, height: 36 },
                        large: { width: 56, height: 48 }
                    }
                };

                const config = rockConfig[type][size];

                // Add some seeded variation (±25%)
                const rockWidth = config.width * (0.75 + seededRandom(seed + 1) * 0.5);
                const rockHeight = config.height * (0.75 + seededRandom(seed + 2) * 0.5);

                // Create rock collision data
                const collision = {
                    x: centerX - rockWidth/2,
                    y: centerY - rockHeight/2,
                    width: rockWidth,
                    height: rockHeight,
                    centerX: centerX,
                    centerY: centerY,
                    radius: Math.max(rockWidth, rockHeight)/2,
                    health: 150, // Rocks are tougher than trees
                    maxHealth: 150,
                    type: 'rock'
                };

                // Store visual data for rendering
                const visualData = {
                    centerX: centerX,
                    centerY: centerY,
                    width: rockWidth,
                    height: rockHeight,
                    type: type,
                    baseColor: type === 'granite' ? '#696969' : '#708090', // Dark gray or slate gray
                    highlightColor: type === 'granite' ? '#A9A9A9' : '#B0C4DE', // Light gray highlights
                    seed: seed
                };

                return {
                    collision: collision,
                    visual: visualData,
                    bounds: {
                        x: centerX - rockWidth/2,
                        y: centerY - rockHeight/2,
                        width: rockWidth,
                        height: rockHeight,
                        centerX: centerX,
                        centerY: centerY
                    }
                };
            }
        };

        // Demo structures - using the new grid system
        function generateDemoStructures() {
            const additionalWalls = [];

            // Create a secondary building to the north (coordinates will be snapped to grid centers)
            const northBuilding = StructureGenerator.createBuilding(0, -256, 2, 2, {
                doorSides: ['bottom'],
                wallColor: '#8B7D6B', // Tan color
                doorColor: '#6B5B47'
            });
            additionalWalls.push(...northBuilding.walls);
            doors.push(...northBuilding.doors);

            // Create a watchtower to the east (coordinates will be snapped to grid centers)
            const eastTower = StructureGenerator.createWatchtower(256, 0);
            additionalWalls.push(...eastTower.walls);

            // Create defensive wall segments (coordinates will be snapped to grid centers)
            const wallSegments = [
                StructureGenerator.createWallSegment(-64, 128, 192, 128), // South wall (y=128 is grid center)
                StructureGenerator.createWallSegment(-64, -64, -64, 128), // West wall (x=-64 is grid center)
                StructureGenerator.createWallSegment(192, -64, 192, 128)   // East wall (x=192 is grid center)
            ];

            wallSegments.forEach(segments => {
                additionalWalls.push(...segments);
            });

            // Add all new walls to the global walls array
            walls.push(...additionalWalls);

            // Create some demo trees using grid coordinates
            const demoTrees = [
                StructureGenerator.createTree(-2, -4, null, 'oak', 'large'),  // Grid position (-2, -4)
                StructureGenerator.createTree(4, -2, null, 'oak', 'medium'),  // Grid position (4, -2)
                StructureGenerator.createTree(-3, 3, null, 'oak', 'small'),   // Grid position (-3, 3)
                StructureGenerator.createTree(2, 4, null, 'oak', 'medium'),   // Grid position (2, 4)
            ];

            // Create demo rocks
            const demoRocks = [
                StructureGenerator.createRock(-1, -2, null, 'granite', 'medium'),  // Grid position (-1, -2)
                StructureGenerator.createRock(3, 1, null, 'boulder', 'large'),     // Grid position (3, 1)
                StructureGenerator.createRock(-4, 1, null, 'granite', 'small'),    // Grid position (-4, 1)
                StructureGenerator.createRock(1, -3, null, 'boulder', 'medium'),   // Grid position (1, -3)
            ];

            // Store trees and rocks globally for collision and rendering
            if (!window.gameObjects) window.gameObjects = {};
            window.gameObjects.trees = demoTrees;
            window.gameObjects.rocks = demoRocks;

        }

        // Camera system - Among Us style follow camera
        const camera = {
            x: 0, // Current camera world position
            y: 0,
            targetX: 0, // Where camera wants to be
            targetY: 0,
            deadZoneRadius: 80, // Player can move this far from center before camera follows
            followSpeed: 0.1, // How smoothly camera catches up (0.05 = slow, 0.2 = fast)
            screenCenterX: 0, // Screen center coordinates (updated on resize)
            screenCenterY: 0
        };

        resizeCanvas();

        // Initialize camera to player position
        function initializeCamera() {
            if (typeof camera === 'undefined' || typeof player === 'undefined') return;
            camera.screenCenterX = canvas.width / 2;
            camera.screenCenterY = canvas.height / 2;
            camera.x = player.x;
            camera.y = player.y;
            camera.targetX = player.x;
            camera.targetY = player.y;
        }

        // Update camera to follow player with dead zone
        function updateCamera() {
            if (typeof camera === 'undefined' || typeof player === 'undefined') return;

            // Calculate distance from player to current camera target
            const dx = player.x - camera.targetX;
            const dy = player.y - camera.targetY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            const oldCameraX = camera.x;
            const oldCameraY = camera.y;

            // If player is outside dead zone, move camera target
            if (distance > camera.deadZoneRadius) {
                const angle = Math.atan2(dy, dx);
                // Move target to edge of dead zone in direction of player
                camera.targetX = player.x - Math.cos(angle) * camera.deadZoneRadius;
                camera.targetY = player.y - Math.sin(angle) * camera.deadZoneRadius;
            }

            // Smoothly move camera towards target (lerp)
            camera.x += (camera.targetX - camera.x) * camera.followSpeed;
            camera.y += (camera.targetY - camera.y) * camera.followSpeed;

            // Debug: log significant camera changes
            if (Math.abs(camera.x - oldCameraX) > 1 || Math.abs(camera.y - oldCameraY) > 1) {
                console.log('CAMERA MOVED:', 'from', oldCameraX.toFixed(2), oldCameraY.toFixed(2),
                           'to', camera.x.toFixed(2), camera.y.toFixed(2),
                           'player:', player.x, player.y, 'target:', camera.targetX.toFixed(2), camera.targetY.toFixed(2));
            }
        }

        function drawTerrain() {
            // Draw background
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(-2000, -2000, 4000, 4000);

            // Draw grid lines
            ctx.strokeStyle = '#404040';
            ctx.lineWidth = 1;

            // Draw grid lines - offset so (0,0) is CENTER of a grid square, not intersection
            const gridRange = 2000;
            const gridOffset = GRID_SIZE / 2; // Offset grid by half tile size
            const gridStart = Math.floor(-gridRange / GRID_SIZE) * GRID_SIZE + gridOffset;
            const gridEnd = Math.ceil(gridRange / GRID_SIZE) * GRID_SIZE + gridOffset;

            // Draw vertical lines
            for (let x = gridStart; x <= gridEnd; x += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(x, -gridRange);
                ctx.lineTo(x, gridRange);
                ctx.stroke();
            }

            // Draw horizontal lines
            for (let y = gridStart; y <= gridEnd; y += GRID_SIZE) {
                ctx.beginPath();
                ctx.moveTo(-gridRange, y);
                ctx.lineTo(gridRange, y);
                ctx.stroke();
            }

            // Add scattered environmental objects
            drawEnvironmentalObjects();
        }

        function drawEnvironmentalObjects() {
            const area = 1200;
            const startX = -area / 2;
            const startY = -area / 2;
            const objectDensity = 0.6; // Objects per grid cell

            // Align object grid to world coordinates
            const gridStartX = Math.floor(startX / OBJECT_GRID_SIZE) * OBJECT_GRID_SIZE;
            const gridStartY = Math.floor(startY / OBJECT_GRID_SIZE) * OBJECT_GRID_SIZE;

            for (let x = gridStartX; x < startX + area; x += OBJECT_GRID_SIZE) {
                for (let y = gridStartY; y < startY + area; y += OBJECT_GRID_SIZE) {
                    // Use grid coordinates as seed for consistent placement
                    const gridX = x / OBJECT_GRID_SIZE;
                    const gridY = y / OBJECT_GRID_SIZE;
                    const seed = Math.abs((gridX * 73 + gridY * 37) % 1000);

                    if (seed < objectDensity * 1000) {
                        // Place object within this grid cell
                        const objX = x + (seed % (OBJECT_GRID_SIZE - 20)) + 10;
                        const objY = y + ((seed * 17) % (OBJECT_GRID_SIZE - 20)) + 10;

                        // Different object types based on seed
                        const objType = seed % 5;

                        if (objType === 0) {
                            // Small rocks
                            ctx.fillStyle = '#4a4a4a';
                            ctx.beginPath();
                            ctx.arc(objX, objY, 3 + (seed % 4), 0, Math.PI * 2);
                            ctx.fill();
                        } else if (objType === 1) {
                            // Debris pieces
                            ctx.fillStyle = '#3a3a3a';
                            ctx.fillRect(objX - 2, objY - 2, 4 + (seed % 6), 2 + (seed % 3));
                        } else if (objType === 2) {
                            // Dark stains
                            ctx.fillStyle = '#1a1a1a';
                            ctx.beginPath();
                            ctx.arc(objX, objY, 8 + (seed % 12), 0, Math.PI * 2);
                            ctx.fill();
                        } else if (objType === 3) {
                            // Small cracks
                            ctx.strokeStyle = '#1a1a1a';
                            ctx.lineWidth = 1;
                            ctx.beginPath();
                            ctx.moveTo(objX - 5, objY);
                            ctx.lineTo(objX + 5 + (seed % 10), objY + (seed % 6) - 3);
                            ctx.stroke();
                        } else {
                            // Scattered rubble clusters
                            ctx.fillStyle = '#353535';
                            for (let i = 0; i < 3; i++) {
                                const rubbleX = objX + (seed * (i + 1) % 16) - 8;
                                const rubbleY = objY + ((seed * (i + 3)) % 16) - 8;
                                ctx.fillRect(rubbleX, rubbleY, 2 + (seed % 3), 2 + (seed % 3));
                            }
                        }
                    }
                }
            }
        }

        function drawWalls() {
            // Draw doors FIRST so they appear behind walls
            doors.forEach(door => {
                ctx.fillStyle = door.color;

                // Draw double doors that slide into wall pockets (behind walls)
                const halfWidth = door.width * 0.5;

                // Calculate available wall pocket space on each side
                const wallGapWidth = (192 - 64) / 2; // (size - doorSize) / 2 = 64px
                const maxSlideDistance = Math.min(halfWidth, wallGapWidth); // Don't slide beyond wall pocket
                const slideDistance = maxSlideDistance * door.openAmount; // Proportional slide distance
                const panelWidth = halfWidth; // Each panel is always half door width

                // Always draw full panels (they'll be hidden by walls when sliding)
                // Left door panel - starts at door.x, slides left into wall pocket
                const leftPanelX = door.x - slideDistance;
                ctx.fillRect(leftPanelX, door.y, panelWidth, door.height);

                // Right door panel - starts at door.x + halfWidth, slides right into wall pocket
                const rightPanelX = door.x + halfWidth + slideDistance;
                ctx.fillRect(rightPanelX, door.y, panelWidth, door.height);
            });

            // Draw walls AFTER doors so they cover sliding panels
            walls.forEach(wall => {
                ctx.fillStyle = wall.color;
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            });

            // Draw trees with visual foliage (rendered after walls)
            if (window.gameObjects && window.gameObjects.trees) {
                window.gameObjects.trees.forEach(tree => {
                    const visual = tree.visual;

                    // Draw trunk as circle (top-down view)
                    ctx.fillStyle = '#8B4513'; // Brown trunk
                    ctx.beginPath();
                    ctx.arc(visual.centerX, visual.centerY, visual.trunkWidth/2, 0, 2 * Math.PI);
                    ctx.fill();

                    // Note: Canopy will be drawn after player for proper layering

                });
            }

            // Draw rocks
            if (window.gameObjects && window.gameObjects.rocks) {
                window.gameObjects.rocks.forEach(rock => {
                    const visual = rock.visual;

                    // Draw rock as irregular oval shape
                    ctx.save();

                    // Main rock body
                    ctx.fillStyle = visual.baseColor;
                    ctx.beginPath();
                    ctx.ellipse(visual.centerX, visual.centerY, visual.width/2, visual.height/2, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    // Add some texture/highlights
                    ctx.fillStyle = visual.highlightColor;
                    ctx.globalAlpha = 0.3;

                    // Small highlight spots for texture
                    const seed = visual.seed;
                    function seededRandom(s) {
                        s = Math.sin(s) * 10000;
                        return s - Math.floor(s);
                    }

                    for (let i = 0; i < 3; i++) {
                        const spotX = visual.centerX + (seededRandom(seed + i * 3) - 0.5) * visual.width * 0.6;
                        const spotY = visual.centerY + (seededRandom(seed + i * 3 + 1) - 0.5) * visual.height * 0.6;
                        const spotSize = seededRandom(seed + i * 3 + 2) * 4 + 2;

                        ctx.beginPath();
                        ctx.arc(spotX, spotY, spotSize, 0, 2 * Math.PI);
                        ctx.fill();
                    }

                    ctx.restore();
                });
            }
        }
        
        function drawPlayerFrame(drawCtx, x, y, frame, variant, direction = 'down') {
            const size = 2.5; // Slightly larger for better detail

            // Get colors from the selected variant
            const colors = characterVariants[variant];
            const { skinColor, hoodColor, hoodShadow, vestGray, vestDark, orangeGear, pantsGreen, pantsDark, bootsBlack } = colors;

            // Animation offsets
            const walkCycle = frame % 3;
            const armOffset = walkCycle === 1 ? -size/2 : (walkCycle === 2 ? size/2 : 0);
            const legOffset = walkCycle === 1 ? -size/2 : (walkCycle === 2 ? size/2 : 0);

            drawCtx.save();

            // Handle direction-specific rendering and mirroring
            const isLeftFacing = direction === 'left' || direction === 'up-left' || direction === 'down-left';
            if (isLeftFacing) {
                drawCtx.translate(x, 0);
                drawCtx.scale(-1, 1);
                drawCtx.translate(-x, 0);
            }

            // Use the actual direction for isometric views
            let baseDirection = direction;

            if (baseDirection === 'down') {
                // FRONT VIEW - like your original image
                // Hood/Helmet with angular shape
                drawCtx.fillStyle = hoodColor;
                drawCtx.fillRect(x - 6*size, y - 12*size, 12*size, 10*size);
                // Hood shadow and details
                drawCtx.fillStyle = hoodShadow;
                drawCtx.fillRect(x - 6*size, y - 12*size, 12*size, 2*size);
                drawCtx.fillRect(x - 6*size, y - 10*size, 2*size, 8*size);
                drawCtx.fillRect(x + 4*size, y - 10*size, 2*size, 8*size);

                // Face opening - rectangular like your image
                drawCtx.fillStyle = skinColor;
                drawCtx.fillRect(x - 3*size, y - 8*size, 6*size, 5*size);

                // Eyes - simple black rectangles
                drawCtx.fillStyle = '#000000';
                drawCtx.fillRect(x - 2*size, y - 7*size, size, size);
                drawCtx.fillRect(x + size, y - 7*size, size, size);

            } else if (baseDirection === 'up') {
                // BACK VIEW - show back of hood
                drawCtx.fillStyle = hoodColor;
                drawCtx.fillRect(x - 6*size, y - 12*size, 12*size, 10*size);
                // Back hood details
                drawCtx.fillStyle = hoodShadow;
                drawCtx.fillRect(x - 5*size, y - 11*size, 10*size, 8*size);
                drawCtx.fillRect(x - 4*size, y - 10*size, 8*size, 6*size);

            } else if (baseDirection === 'right') {
                // RIGHT SIDE VIEW - proper profile
                // Hood - narrower from side
                drawCtx.fillStyle = hoodColor;
                drawCtx.fillRect(x - 4*size, y - 12*size, 8*size, 10*size);
                // Hood shadow - side profile
                drawCtx.fillStyle = hoodShadow;
                drawCtx.fillRect(x - 4*size, y - 12*size, 8*size, 2*size);
                drawCtx.fillRect(x - 4*size, y - 10*size, 2*size, 8*size);

                // Profile face - smaller, more realistic
                drawCtx.fillStyle = skinColor;
                drawCtx.fillRect(x + size, y - 8*size, 2*size, 4*size);

                // One eye visible in profile - positioned correctly
                drawCtx.fillStyle = '#000000';
                drawCtx.fillRect(x + 2*size, y - 7*size, size, size);

            } else if (baseDirection === 'left') {
                // LEFT SIDE VIEW - same as right, will be mirrored by transform
                // Hood - narrower from side
                drawCtx.fillStyle = hoodColor;
                drawCtx.fillRect(x - 4*size, y - 12*size, 8*size, 10*size);
                // Hood shadow - side profile
                drawCtx.fillStyle = hoodShadow;
                drawCtx.fillRect(x - 4*size, y - 12*size, 8*size, 2*size);
                drawCtx.fillRect(x - 4*size, y - 10*size, 2*size, 8*size);

                // Profile face - smaller, more realistic
                drawCtx.fillStyle = skinColor;
                drawCtx.fillRect(x + size, y - 8*size, 2*size, 4*size);

                // One eye visible in profile - positioned correctly
                drawCtx.fillStyle = '#000000';
                drawCtx.fillRect(x + 2*size, y - 7*size, size, size);

            } else if (baseDirection === 'down-right' || baseDirection === 'down-left') {
                // FRONT-DIAGONAL VIEW - 3/4 isometric
                // Hood - slightly angled
                drawCtx.fillStyle = hoodColor;
                drawCtx.fillRect(x - 5*size, y - 12*size, 10*size, 10*size);
                // Hood shadow with angle
                drawCtx.fillStyle = hoodShadow;
                drawCtx.fillRect(x - 5*size, y - 12*size, 10*size, 2*size);
                drawCtx.fillRect(x - 5*size, y - 10*size, 2*size, 6*size);

                // Angled face opening
                drawCtx.fillStyle = skinColor;
                drawCtx.fillRect(x - 2*size, y - 8*size, 5*size, 4*size);

                // Two eyes visible but closer together
                drawCtx.fillStyle = '#000000';
                drawCtx.fillRect(x - size, y - 7*size, size, size);
                drawCtx.fillRect(x + size, y - 7*size, size, size);

            } else if (baseDirection === 'up-right' || baseDirection === 'up-left') {
                // BACK-DIAGONAL VIEW - 3/4 isometric back
                // Hood - angled back view
                drawCtx.fillStyle = hoodColor;
                drawCtx.fillRect(x - 5*size, y - 12*size, 10*size, 10*size);
                // Back hood details with angle
                drawCtx.fillStyle = hoodShadow;
                drawCtx.fillRect(x - 4*size, y - 11*size, 8*size, 7*size);
                drawCtx.fillRect(x - 3*size, y - 10*size, 6*size, 5*size);
            }

            // Tactical vest - main body
            drawCtx.fillStyle = vestGray;
            drawCtx.fillRect(x - 5*size, y - 2*size, 10*size, 9*size);

            // Vest details and shadows
            drawCtx.fillStyle = vestDark;
            drawCtx.fillRect(x - 5*size, y - 2*size, 2*size, 9*size); // Left side
            drawCtx.fillRect(x + 3*size, y - 2*size, 2*size, 9*size);  // Right side

            // Orange chest piece - only visible from front and front-diagonal views
            if (baseDirection === 'down' || baseDirection === 'down-left' || baseDirection === 'down-right') {
                drawCtx.fillStyle = orangeGear;
                drawCtx.fillRect(x - 2*size, y + size, 4*size, 3*size);
            }

            // Arms based on direction and shooting state
            drawCtx.fillStyle = vestGray;

            // Get shooting state from player object (passed as variant parameter context)
            const isShooting = player.isShooting;

            if (baseDirection === 'down') {
                // Front view
                if (isShooting) {
                    // Shooting pose - only left arm raised, right arm normal
                    drawCtx.fillRect(x - 7*size, y - 2*size, 2*size, 5*size); // Left arm raised
                    drawCtx.fillRect(x + 5*size, y - armOffset, 2*size, 7*size); // Right arm normal
                    // Hands
                    drawCtx.fillStyle = skinColor;
                    drawCtx.fillRect(x - 7*size, y + 2*size, 2*size, 2*size); // Left hand extended
                    drawCtx.fillRect(x + 5*size, y + 6*size - armOffset, 2*size, 2*size); // Right hand normal
                } else {
                    // Normal walking pose
                    drawCtx.fillRect(x - 7*size, y + armOffset, 2*size, 7*size); // Left arm
                    drawCtx.fillRect(x + 5*size, y - armOffset, 2*size, 7*size); // Right arm
                    // Hands
                    drawCtx.fillStyle = skinColor;
                    drawCtx.fillRect(x - 7*size, y + 6*size + armOffset, 2*size, 2*size);
                    drawCtx.fillRect(x + 5*size, y + 6*size - armOffset, 2*size, 2*size);
                }
            } else if (baseDirection === 'up') {
                // Back view
                if (isShooting) {
                    // Shooting pose from back - right arm raised
                    drawCtx.fillRect(x - 7*size, y + armOffset, 2*size, 7*size); // Left arm normal
                    drawCtx.fillRect(x + 5*size, y - 2*size, 2*size, 5*size); // Right arm raised
                    // Hands
                    drawCtx.fillStyle = skinColor;
                    drawCtx.fillRect(x - 7*size, y + 6*size + armOffset, 2*size, 2*size); // Left hand normal
                    drawCtx.fillRect(x + 5*size, y + 2*size, 2*size, 2*size); // Right hand raised
                } else {
                    // Normal walking pose
                    drawCtx.fillRect(x - 7*size, y + armOffset, 2*size, 7*size); // Left arm
                    drawCtx.fillRect(x + 5*size, y - armOffset, 2*size, 7*size); // Right arm
                    // Hands
                    drawCtx.fillStyle = skinColor;
                    drawCtx.fillRect(x - 7*size, y + 6*size + armOffset, 2*size, 2*size);
                    drawCtx.fillRect(x + 5*size, y + 6*size - armOffset, 2*size, 2*size);
                }
            } else if (baseDirection === 'right') {
                // Right side view
                if (isShooting) {
                    // Shooting pose - arm extended forward
                    drawCtx.fillRect(x - size, y - 2*size, 2*size, 5*size); // Arm raised
                    drawCtx.fillRect(x + size, y - 2*size, 3*size, 2*size); // Extended forward
                    drawCtx.fillStyle = skinColor;
                    drawCtx.fillRect(x + 3*size, y - 2*size, 2*size, 2*size); // Hand extended
                } else {
                    // Normal pose
                    drawCtx.fillRect(x - size, y + armOffset, 2*size, 7*size);
                    drawCtx.fillStyle = skinColor;
                    drawCtx.fillRect(x - size, y + 6*size + armOffset, 2*size, 2*size);
                }
            } else if (baseDirection === 'left') {
                // Left side view - use same coordinates as right, transform will mirror
                if (isShooting) {
                    // Shooting pose - same as right side (will be automatically mirrored)
                    drawCtx.fillRect(x - size, y - 2*size, 2*size, 5*size); // Arm raised
                    drawCtx.fillRect(x + size, y - 2*size, 3*size, 2*size); // Extended forward
                    drawCtx.fillStyle = skinColor;
                    drawCtx.fillRect(x + 3*size, y - 2*size, 2*size, 2*size); // Hand extended
                } else {
                    // Normal pose - same as right side
                    drawCtx.fillRect(x - size, y + armOffset, 2*size, 7*size);
                    drawCtx.fillStyle = skinColor;
                    drawCtx.fillRect(x - size, y + 6*size + armOffset, 2*size, 2*size);
                }
            } else if (baseDirection === 'down-right' || baseDirection === 'down-left' || baseDirection === 'up-right' || baseDirection === 'up-left') {
                // Diagonal view - show partial arms (3/4 view)
                if (isShooting) {
                    // Diagonal shooting pose - one arm more visible
                    drawCtx.fillRect(x - 2*size, y - size, 2*size, 6*size); // Main arm
                    drawCtx.fillRect(x + 2*size, y + size, size, 4*size);   // Partial second arm
                    drawCtx.fillStyle = skinColor;
                    drawCtx.fillRect(x - 2*size, y + 4*size, 2*size, 2*size); // Main hand
                    drawCtx.fillRect(x + 2*size, y + 4*size, size, 2*size);   // Partial hand
                } else {
                    // Normal diagonal pose
                    drawCtx.fillRect(x - 2*size, y + armOffset, 2*size, 7*size); // Main arm
                    drawCtx.fillRect(x + 2*size, y - armOffset + size, size, 5*size); // Partial arm
                    drawCtx.fillStyle = skinColor;
                    drawCtx.fillRect(x - 2*size, y + 5*size + armOffset, 2*size, 2*size);
                    drawCtx.fillRect(x + 2*size, y + 4*size - armOffset, size, 2*size);
                }
            }

            // Tactical pants - direction-specific leg visibility
            drawCtx.fillStyle = pantsGreen;
            if (baseDirection === 'down' || baseDirection === 'up') {
                // Front/back view - both legs visible
                drawCtx.fillRect(x - 4*size, y + 7*size + legOffset, 3*size, 7*size); // Left leg
                drawCtx.fillRect(x + size, y + 7*size - legOffset, 3*size, 7*size);   // Right leg

                // Pants shadows/details
                drawCtx.fillStyle = pantsDark;
                drawCtx.fillRect(x - 4*size, y + 7*size + legOffset, size, 7*size);
                drawCtx.fillRect(x + size, y + 7*size - legOffset, size, 7*size);

                // Combat boots
                drawCtx.fillStyle = bootsBlack;
                drawCtx.fillRect(x - 4*size, y + 13*size + legOffset, 3*size, 3*size);
                drawCtx.fillRect(x + size, y + 13*size - legOffset, 3*size, 3*size);
            } else if (baseDirection === 'down-right' || baseDirection === 'down-left' || baseDirection === 'up-right' || baseDirection === 'up-left') {
                // Diagonal view - both legs visible but with depth
                // Back leg (darker, partially hidden)
                drawCtx.fillStyle = pantsDark;
                drawCtx.fillRect(x - 3*size, y + 7*size - legOffset, 2*size, 7*size);
                drawCtx.fillStyle = bootsBlack;
                drawCtx.fillRect(x - 3*size, y + 13*size - legOffset, 2*size, 3*size);

                // Front leg (brighter, more visible)
                drawCtx.fillStyle = pantsGreen;
                drawCtx.fillRect(x, y + 7*size + legOffset, 3*size, 7*size);
                drawCtx.fillStyle = pantsDark;
                drawCtx.fillRect(x, y + 7*size + legOffset, size, 7*size);
                drawCtx.fillStyle = bootsBlack;
                drawCtx.fillRect(x, y + 13*size + legOffset, 3*size, 3*size);

            } else {
                // Side view - only one leg visible (the closer one)
                // Show second leg only when walking (frame > 0)
                if (frame > 0) {
                    // Walking - show back leg first (darker)
                    drawCtx.fillStyle = pantsDark;
                    drawCtx.fillRect(x - 2*size, y + 7*size - legOffset, 3*size, 7*size);
                    drawCtx.fillStyle = bootsBlack;
                    drawCtx.fillRect(x - 2*size, y + 13*size - legOffset, 3*size, 3*size);
                }

                // Front leg (always visible)
                drawCtx.fillStyle = pantsGreen;
                drawCtx.fillRect(x - size, y + 7*size + legOffset, 3*size, 7*size);
                drawCtx.fillStyle = pantsDark;
                drawCtx.fillRect(x - size, y + 7*size + legOffset, size, 7*size);
                drawCtx.fillStyle = bootsBlack;
                drawCtx.fillRect(x - size, y + 13*size + legOffset, 3*size, 3*size);
            }

            drawCtx.restore();
        }

        function checkWallCollision(x, y, radius) {
            for (const wall of walls) {
                const testX = Math.max(wall.x, Math.min(x, wall.x + wall.width));
                const testY = Math.max(wall.y, Math.min(y, wall.y + wall.height));
                const distX = x - testX;
                const distY = y - testY;
                const distance = Math.sqrt((distX * distX) + (distY * distY));
                if (distance <= radius) {
                    return true;
                }
            }
            for (const door of doors) {
                if (door.openAmount < 1) {
                    // Check collision only with visible parts of door panels
                    const halfWidth = door.width * 0.5;
                    const wallGapWidth = (192 - 64) / 2; // Available wall pocket space
                    const maxSlideDistance = Math.min(halfWidth, wallGapWidth); // Don't slide beyond wall pocket
                    const slideDistance = maxSlideDistance * door.openAmount;
                    const panelWidth = halfWidth;

                    let distance = Infinity;

                    if (door.openAmount < 1) {
                        // Left door panel collision - only visible part in doorway
                        const leftPanelX = door.x - slideDistance;
                        const leftVisibleStart = Math.max(door.x, leftPanelX);
                        const leftVisibleEnd = Math.min(door.x + halfWidth, leftPanelX + panelWidth);
                        const leftVisibleWidth = Math.max(0, leftVisibleEnd - leftVisibleStart);

                        if (leftVisibleWidth > 0) {
                            const testXLeft = Math.max(leftVisibleStart, Math.min(x, leftVisibleStart + leftVisibleWidth));
                            const testYLeft = Math.max(door.y, Math.min(y, door.y + door.height));
                            const distXLeft = x - testXLeft;
                            const distYLeft = y - testYLeft;
                            const distanceLeft = Math.sqrt((distXLeft * distXLeft) + (distYLeft * distYLeft));
                            distance = Math.min(distance, distanceLeft);
                        }

                        // Right door panel collision - only visible part in doorway
                        const rightPanelX = door.x + halfWidth + slideDistance;
                        const rightVisibleStart = Math.max(door.x + halfWidth, rightPanelX);
                        const rightVisibleEnd = Math.min(door.x + door.width, rightPanelX + panelWidth);
                        const rightVisibleWidth = Math.max(0, rightVisibleEnd - rightVisibleStart);

                        if (rightVisibleWidth > 0) {
                            const testXRight = Math.max(rightVisibleStart, Math.min(x, rightVisibleStart + rightVisibleWidth));
                            const testYRight = Math.max(door.y, Math.min(y, door.y + door.height));
                            const distXRight = x - testXRight;
                            const distYRight = y - testYRight;
                            const distanceRight = Math.sqrt((distXRight * distXRight) + (distYRight * distYRight));
                            distance = Math.min(distance, distanceRight);
                        }
                    }
                    if (distance <= radius) {
                        return true;
                    }
                }
            }
            return false;
        }

        function checkTreeCollision(x, y, radius) {
            if (!window.gameObjects || !window.gameObjects.trees) {
                return false;
            }

            for (const tree of window.gameObjects.trees) {
                const collision = tree.collision;

                // Check collision with tree trunk (rectangular collision box)
                const testX = Math.max(collision.x, Math.min(x, collision.x + collision.width));
                const testY = Math.max(collision.y, Math.min(y, collision.y + collision.height));
                const distX = x - testX;
                const distY = y - testY;
                const distance = Math.sqrt((distX * distX) + (distY * distY));

                if (distance <= radius) {
                    return true;
                }
            }
            return false;
        }

        function checkRockCollision(x, y, radius) {
            if (!window.gameObjects || !window.gameObjects.rocks) {
                return false;
            }

            for (const rock of window.gameObjects.rocks) {
                const collision = rock.collision;

                // Check collision with rock (rectangular collision box)
                const testX = Math.max(collision.x, Math.min(x, collision.x + collision.width));
                const testY = Math.max(collision.y, Math.min(y, collision.y + collision.height));
                const distX = x - testX;
                const distY = y - testY;
                const distance = Math.sqrt((distX * distX) + (distY * distY));

                if (distance <= radius) {
                    return true;
                }
            }
            return false;
        }

        function createWoodPlanks(x, y, count) {
            // Create wood plank collectibles when tree is destroyed
            if (!window.gameObjects.woodPlanks) {
                window.gameObjects.woodPlanks = [];
            }

            for (let i = 0; i < count; i++) {
                // Scatter planks around the tree location
                const offsetX = (Math.random() - 0.5) * 60;
                const offsetY = (Math.random() - 0.5) * 60;

                window.gameObjects.woodPlanks.push({
                    x: x + offsetX,
                    y: y + offsetY,
                    width: 20,
                    height: 8,
                    color: '#D2691E', // Saddle brown
                    collected: false,
                    value: 1 // How many wood units this plank gives
                });
            }
        }

        function drawWoodPlanks() {
            if (!window.gameObjects || !window.gameObjects.woodPlanks) return;

            window.gameObjects.woodPlanks.forEach(plank => {
                if (!plank.collected) {
                    // Draw wood plank
                    ctx.fillStyle = plank.color;
                    ctx.fillRect(plank.x - plank.width/2, plank.y - plank.height/2, plank.width, plank.height);

                    // Add wood grain lines
                    ctx.strokeStyle = '#8B4513'; // Darker brown
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(plank.x - plank.width/2 + 3, plank.y - plank.height/2 + 2);
                    ctx.lineTo(plank.x + plank.width/2 - 3, plank.y - plank.height/2 + 2);
                    ctx.moveTo(plank.x - plank.width/2 + 3, plank.y + plank.height/2 - 2);
                    ctx.lineTo(plank.x + plank.width/2 - 3, plank.y + plank.height/2 - 2);
                    ctx.stroke();
                }
            });
        }

        function createStone(x, y, count) {
            // Create stone piece collectibles when rock is destroyed
            if (!window.gameObjects.stone) {
                window.gameObjects.stone = [];
            }

            for (let i = 0; i < count; i++) {
                // Scatter stone pieces around the rock location
                const offsetX = (Math.random() - 0.5) * 60;
                const offsetY = (Math.random() - 0.5) * 60;

                window.gameObjects.stone.push({
                    x: x + offsetX,
                    y: y + offsetY,
                    width: 12,
                    height: 10,
                    color: '#808080', // Gray
                    collected: false,
                    value: 1 // How many stone units this piece gives
                });
            }
        }

        function drawStone() {
            if (!window.gameObjects || !window.gameObjects.stone) return;

            window.gameObjects.stone.forEach(stone => {
                if (!stone.collected) {
                    // Draw stone piece as irregular shape
                    ctx.fillStyle = stone.color;
                    ctx.beginPath();
                    ctx.ellipse(stone.x, stone.y, stone.width/2, stone.height/2, 0, 0, 2 * Math.PI);
                    ctx.fill();

                    // Add highlight for texture
                    ctx.fillStyle = '#A9A9A9'; // Light gray highlight
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.ellipse(stone.x - stone.width/4, stone.y - stone.height/4, stone.width/4, stone.height/4, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            });
        }

        function isInsideBase(x, y) {
            const w = canvas.width;
            const h = canvas.height;
            const baseStartX = w / 2 - baseSize / 2;
            const baseStartY = h / 2 - baseSize / 2;
            const baseEndX = w / 2 + baseSize / 2;
            const baseEndY = h / 2 + baseSize / 2;

            return x > baseStartX && x < baseEndX && y > baseStartY && y < baseEndY;
        }


        function updatePlayerPosition() {
            let dx = 0;
            let dy = 0;
            let currentSpeed = player.speed;

            // Apply speed boost if active
            if (activePowerUps.speedBoost > 0) {
                currentSpeed *= 1.5; // 50% speed increase
            }

            // Use accelerometer on mobile, keyboard on desktop
            if (isMobile && motionPermissionGranted) {
                // Convert tilt angles to movement with better sensitivity
                const tiltSensitivity = 1.2;
                const deadZone = 3; // Smaller dead zone for better responsiveness
                const maxTilt = 30; // Maximum useful tilt angle

                // Left-right movement (gamma: -90 to 90, but we use smaller range)
                if (Math.abs(accelerometerData.x) > deadZone) {
                    const clampedTilt = Math.max(-maxTilt, Math.min(maxTilt, accelerometerData.x));
                    dx = (clampedTilt / maxTilt) * currentSpeed * tiltSensitivity;
                }

                // Forward-backward movement (beta in portrait mode)
                // In portrait, neutral is around 0, forward tilt is negative, backward is positive
                const adjustedBeta = accelerometerData.y;
                if (Math.abs(adjustedBeta) > deadZone) {
                    const clampedTilt = Math.max(-maxTilt, Math.min(maxTilt, adjustedBeta));
                    dy = (clampedTilt / maxTilt) * currentSpeed * tiltSensitivity;
                }
            } else {
                // Try gamepad input first, fall back to keyboard
                const gamepadInput = updateGamepadInput();
                let usingGamepad = false;

                if (gamepadInput.dx !== 0 || gamepadInput.dy !== 0) {
                    // Use gamepad movement
                    dx = gamepadInput.dx;
                    dy = gamepadInput.dy;
                    usingGamepad = true;
                } else {
                    // Fall back to keyboard controls
                    if (keys.ArrowUp || keys.w) dy = -currentSpeed;
                    if (keys.ArrowDown || keys.s) dy = currentSpeed;
                    if (keys.ArrowLeft || keys.a) dx = -currentSpeed;
                    if (keys.ArrowRight || keys.d) dx = currentSpeed;
                }

                // Normalize vector for consistent diagonal speed (only for keyboard, gamepad already normalized)
                if (!usingGamepad && dx !== 0 && dy !== 0) {
                    const magnitude = Math.sqrt(dx * dx + dy * dy);
                    dx = (dx / magnitude) * currentSpeed;
                    dy = (dy / magnitude) * currentSpeed;
                }
            }
            
            const newX = player.x + dx;
            const newY = player.y + dy;

            // Check for wall, tree, and rock collisions
            if (!checkWallCollision(newX, player.y, player.radius) && !checkTreeCollision(newX, player.y, player.radius) && !checkRockCollision(newX, player.y, player.radius)) {
                player.x = newX;
            }
            if (!checkWallCollision(player.x, newY, player.radius) && !checkTreeCollision(player.x, newY, player.radius) && !checkRockCollision(player.x, newY, player.radius)) {
                player.y = newY;
            }

            // Update playerDirection for shooting mechanics
            if (dx !== 0 || dy !== 0) {
                playerDirection.x = dx;
                playerDirection.y = dy;

                // Update character direction based on movement (8 directions)
                // Use wider zones for diagonals to prevent flickering
                const angle = Math.atan2(dy, dx);
                const angleDegrees = (angle * 180 / Math.PI + 360) % 360;

                // Determine new direction with wider diagonal zones
                let newDirection;
                if (angleDegrees >= 345 || angleDegrees < 15) {
                    newDirection = 'right';
                } else if (angleDegrees >= 15 && angleDegrees < 75) {
                    newDirection = 'down-right';
                } else if (angleDegrees >= 75 && angleDegrees < 105) {
                    newDirection = 'down';
                } else if (angleDegrees >= 105 && angleDegrees < 165) {
                    newDirection = 'down-left';
                } else if (angleDegrees >= 165 && angleDegrees < 195) {
                    newDirection = 'left';
                } else if (angleDegrees >= 195 && angleDegrees < 255) {
                    newDirection = 'up-left';
                } else if (angleDegrees >= 255 && angleDegrees < 285) {
                    newDirection = 'up';
                } else if (angleDegrees >= 285 && angleDegrees < 345) {
                    newDirection = 'up-right';
                }

                // Only change direction if it's significantly different (prevent micro-adjustments)
                const currentIsCardinal = ['up', 'down', 'left', 'right'].includes(player.direction);
                const newIsCardinal = ['up', 'down', 'left', 'right'].includes(newDirection);
                const currentIsDiagonal = !currentIsCardinal;
                const newIsDiagonal = !newIsCardinal;

                // If we're currently diagonal and new direction is cardinal, require larger movement
                if (currentIsDiagonal && newIsCardinal) {
                    // Only switch to cardinal if the angle is very close to cardinal
                    if (angleDegrees >= 350 || angleDegrees < 10 ||
                        (angleDegrees >= 80 && angleDegrees < 100) ||
                        (angleDegrees >= 170 && angleDegrees < 190) ||
                        (angleDegrees >= 260 && angleDegrees < 280)) {
                        player.direction = newDirection;
                    }
                } else {
                    // Normal direction update
                    player.direction = newDirection;
                }
            }

            // If mouse is being used and no movement keys are pressed, face the cursor direction
            if (mouseMoved && dx === 0 && dy === 0) {
                const cursorDx = mouseX - player.x;
                const cursorDy = mouseY - player.y;

                // Only update direction if mouse is far enough from player to avoid jittery rotation
                const cursorDistance = Math.hypot(cursorDx, cursorDy);
                if (cursorDistance > 20) {
                    // Calculate 8-directional facing based on cursor position
                    const angle = Math.atan2(cursorDy, cursorDx);
                    const angleDegrees = (angle * 180 / Math.PI + 360) % 360;

                    if (angleDegrees >= 337.5 || angleDegrees < 22.5) {
                        player.direction = 'right';
                    } else if (angleDegrees >= 22.5 && angleDegrees < 67.5) {
                        player.direction = 'down-right';
                    } else if (angleDegrees >= 67.5 && angleDegrees < 112.5) {
                        player.direction = 'down';
                    } else if (angleDegrees >= 112.5 && angleDegrees < 157.5) {
                        player.direction = 'down-left';
                    } else if (angleDegrees >= 157.5 && angleDegrees < 202.5) {
                        player.direction = 'left';
                    } else if (angleDegrees >= 202.5 && angleDegrees < 247.5) {
                        player.direction = 'up-left';
                    } else if (angleDegrees >= 247.5 && angleDegrees < 292.5) {
                        player.direction = 'up';
                    } else if (angleDegrees >= 292.5 && angleDegrees < 337.5) {
                        player.direction = 'up-right';
                    }
                }
            }

            // Handle animation frames
            if (dx !== 0 || dy !== 0) {


                if (Date.now() - player.lastFrameChange > PLAYER_ANIM_SPEED) {
                    player.frame = (player.frame + 1) % 3;
                    player.lastFrameChange = Date.now();
                }
            } else {
                player.frame = 0;
            }

            // World boundary checks - large world boundaries
            const worldSize = 1500; // Large world, camera will keep player visible
            const minX = -worldSize + player.radius;
            const maxX = worldSize - player.radius;
            const minY = -worldSize + player.radius;
            const maxY = worldSize - player.radius;

            player.x = Math.max(minX, Math.min(maxX, player.x));
            player.y = Math.max(minY, Math.min(maxY, player.y));
            
            // Door logic with gradual animation
            doors.forEach(door => {
                const dist = Math.hypot(player.x - (door.x + door.width/2), player.y - (door.y + door.height/2));
                const wasTargetOpen = door.targetOpen;

                // Determine target state - increase detection distance for smoother approach
                if (dist < player.radius + 60) { // Increased from 30 to 60 pixels
                    door.targetOpen = 1; // Fully open
                    if (wasTargetOpen === 0) {
                        audioManager.playSound('doorOpen'); // Sound when starting to open
                    }
                } else {
                    // Check if any enemies are in the doorway before closing
                    let enemyInDoorway = false;

                    // Check zombies
                    for (const zombie of zombies) {
                        if (zombie.x + zombie.size > door.x && zombie.x - zombie.size < door.x + door.width &&
                            zombie.y + zombie.size > door.y && zombie.y - zombie.size < door.y + door.height) {
                            enemyInDoorway = true;
                            // Push enemy to the outside (away from building center)
                            const centerX = 0, centerY = 0; // Building center
                            const directionX = zombie.x - centerX;
                            const directionY = zombie.y - centerY;
                            const length = Math.sqrt(directionX * directionX + directionY * directionY);
                            if (length > 0) {
                                zombie.x = centerX + (directionX / length) * 100; // Push 100px away from center
                                zombie.y = centerY + (directionY / length) * 100;
                            }
                        }
                    }

                    // Check skeletons
                    for (const skeleton of skeletons) {
                        if (skeleton.x + skeleton.size > door.x && skeleton.x - skeleton.size < door.x + door.width &&
                            skeleton.y + skeleton.size > door.y && skeleton.y - skeleton.size < door.y + door.height) {
                            enemyInDoorway = true;
                            // Push enemy to the outside (away from building center)
                            const centerX = 0, centerY = 0; // Building center
                            const directionX = skeleton.x - centerX;
                            const directionY = skeleton.y - centerY;
                            const length = Math.sqrt(directionX * directionX + directionY * directionY);
                            if (length > 0) {
                                skeleton.x = centerX + (directionX / length) * 100; // Push 100px away from center
                                skeleton.y = centerY + (directionY / length) * 100;
                            }
                        }
                    }

                    // Only close door if no enemies are in the way
                    if (!enemyInDoorway) {
                        door.targetOpen = 0; // Fully closed
                        if (wasTargetOpen === 1) {
                            audioManager.playSound('doorOpen'); // Sound when starting to close
                        }
                    }
                }

                // Fast animation to match player movement speed
                const animationSpeed = 0.08; // Much faster - doors open in ~12 frames (~0.2 seconds)
                if (door.openAmount < door.targetOpen) {
                    door.openAmount = Math.min(door.targetOpen, door.openAmount + animationSpeed);
                } else if (door.openAmount > door.targetOpen) {
                    door.openAmount = Math.max(door.targetOpen, door.openAmount - animationSpeed);
                }

                // Update open state for collision detection
                door.open = door.openAmount > 0.5;
            });

            // Update shooting state
            if (player.isShooting && Date.now() > player.shootingEndTime) {
                player.isShooting = false;
            }
        }

        function updateGamepadInput() {
            if (!gamepad) {
                detectGamepad();
                return { dx: 0, dy: 0, aiming: false };
            }

            // Update gamepad state
            gamepad = navigator.getGamepads()[gamepadIndex];
            if (!gamepad) {
                console.log('Gamepad disconnected during update');
                disconnectGamepad();
                return { dx: 0, dy: 0, aiming: false };
            }


            let dx = 0, dy = 0;
            let aimChanged = false;

            // Left stick - Movement with variable speed
            const leftX = applyDeadzone(gamepad.axes[0]);
            const leftY = applyDeadzone(gamepad.axes[1]);

            if (leftX !== 0 || leftY !== 0) {
                // Reset aim direction when movement stick is used
                gamepadAimX = 0;
                gamepadAimY = 0;

                // Calculate stick magnitude for speed scaling
                const stickMagnitude = Math.min(Math.hypot(leftX, leftY), 1.0);

                // Gradual speed curve: slow start, gradual increase, max 75% speed
                // Using a smooth curve for more natural feel

                // Option 1: Current power curve (good for precise movement)
                // const speedMultiplier = Math.pow(stickMagnitude, 1.5) * 0.75;

                // Option 2: Smoother S-curve (more gradual acceleration, then faster)
                const t = stickMagnitude;
                const speedMultiplier = (3 * t * t - 2 * t * t * t) * 0.5;

                // Option 3: Even smoother cubic curve
                // const speedMultiplier = Math.pow(stickMagnitude, 3) * 0.75;

                // Option 4: Sine curve (very smooth acceleration)
                // const speedMultiplier = Math.sin(stickMagnitude * Math.PI / 2) * 0.75;

                // Normalize direction to prevent diagonal speed-up
                const normalizedX = leftX / stickMagnitude;
                const normalizedY = leftY / stickMagnitude;

                dx = normalizedX * player.speed * speedMultiplier;
                dy = normalizedY * player.speed * speedMultiplier;
            }

            // Right stick - Aiming (Twin Stick Shooter style)
            const rightX = applyDeadzone(gamepad.axes[2]);
            const rightY = applyDeadzone(gamepad.axes[3]);

            if (rightX !== 0 || rightY !== 0) {
                // Update aim direction
                const angle = Math.atan2(rightY, rightX);
                const angleDegrees = (angle * 180 / Math.PI + 360) % 360;

                // Same direction logic as movement but for aiming
                if (angleDegrees >= 345 || angleDegrees < 15) {
                    player.direction = 'right';
                } else if (angleDegrees >= 15 && angleDegrees < 75) {
                    player.direction = 'down-right';
                } else if (angleDegrees >= 75 && angleDegrees < 105) {
                    player.direction = 'down';
                } else if (angleDegrees >= 105 && angleDegrees < 165) {
                    player.direction = 'down-left';
                } else if (angleDegrees >= 165 && angleDegrees < 195) {
                    player.direction = 'left';
                } else if (angleDegrees >= 195 && angleDegrees < 255) {
                    player.direction = 'up-left';
                } else if (angleDegrees >= 255 && angleDegrees < 285) {
                    player.direction = 'up';
                } else if (angleDegrees >= 285 && angleDegrees < 345) {
                    player.direction = 'up-right';
                }

                aimChanged = true;

                // Store aim direction for shooting
                gamepadAimX = rightX;
                gamepadAimY = rightY;
            }
            // Note: Don't reset aim here - let it persist until movement stick is used

            // Right Trigger or A button - Shooting
            const shootTriggerPressed = getButtonPressed(7); // RT button (single press)
            const shootTriggerHeld = getButtonHeld(7); // RT button (held down)
            const shootA = getButtonPressed(0); // A button for single shots

            if (currentWeapon === 'assaultRifle') {
                // Handle automatic firing for assault rifle (only with RT trigger held, not A)
                if (shootTriggerHeld && !autoFireInterval) {
                    shoot(0, 0); // Will use gamepad aim direction
                    autoFireInterval = setInterval(() => {
                        if (getButtonHeld(7) && currentWeapon === 'assaultRifle') {
                            shoot(0, 0);
                        } else {
                            clearInterval(autoFireInterval);
                            autoFireInterval = null;
                        }
                    }, ASSAULT_RIFLE_FIRE_RATE);
                } else if (shootA) {
                    // A button fires single shots even for assault rifle
                    shoot(0, 0);
                }
            } else {
                // Single shot weapons work with both RT trigger press and A button
                if (shootTriggerPressed || shootA) {
                    shoot(0, 0);
                }
            }

            // Stop automatic firing when trigger is released
            if (!shootTriggerHeld && autoFireInterval) {
                clearInterval(autoFireInterval);
                autoFireInterval = null;
            }

            // Weapon switching with shoulder buttons
            if (getButtonPressed(4)) { // LB - Previous weapon
                const currentIndex = weapons.indexOf(currentWeapon);
                const prevIndex = (currentIndex - 1 + weapons.length) % weapons.length;
                currentWeapon = weapons[prevIndex];
                updateWeaponDisplay();
                updateAmmoDisplay();
            }
            if (getButtonPressed(5)) { // RB - Next weapon
                const currentIndex = weapons.indexOf(currentWeapon);
                const nextIndex = (currentIndex + 1) % weapons.length;
                currentWeapon = weapons[nextIndex];
                updateWeaponDisplay();
                updateAmmoDisplay();
            }

            // D-Pad weapon selection
            if (getButtonPressed(12)) { // D-Pad Up
                currentWeapon = 'axe';
                updateWeaponDisplay();
                updateAmmoDisplay();
            }
            if (getButtonPressed(13)) { // D-Pad Down
                currentWeapon = 'pistol';
                updateWeaponDisplay();
                updateAmmoDisplay();
            }
            if (getButtonPressed(14)) { // D-Pad Left
                currentWeapon = 'shotgun';
                updateWeaponDisplay();
                updateAmmoDisplay();
            }
            if (getButtonPressed(15)) { // D-Pad Right
                currentWeapon = 'assaultRifle';
                updateWeaponDisplay();
                updateAmmoDisplay();
            }

            return { dx, dy, aiming: aimChanged };
        }

        function spawnZombie() {
            if (zombies.length >= MAX_ZOMBIES) return;
            if (Date.now() - lastZombieSpawn < ZOMBIE_SPAWN_INTERVAL) return;
            lastZombieSpawn = Date.now();

            let x, y;
            const buildingSize = 192; // Grid-aligned building size
            const buildingHalfSize = buildingSize / 2;
            const worldSize = 1000; // Spawn within 1000 units from center
            const playerSafeDistance = 200; // Safe distance around player

            // Generate random position anywhere in world, but not inside building or near player
            let distToPlayer;
            do {
                x = (Math.random() - 0.5) * worldSize * 2;
                y = (Math.random() - 0.5) * worldSize * 2;
                distToPlayer = Math.sqrt((x - player.x) * (x - player.x) + (y - player.y) * (y - player.y));
            } while ((Math.abs(x) < buildingHalfSize + 50 && Math.abs(y) < buildingHalfSize + 50) ||
                     distToPlayer < playerSafeDistance);

            zombies.push({
                x, y,
                size: 15,
                speed: (Math.random() * 0.5 + 0.5) * 0.5, // Half the speed of skeletons
                frame: 0,
                lastFrameChange: Date.now(),
                active: false,
                idleDirection: { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 }
            });
        }
        
        function spawnSkeleton() {
            if (skeletons.length >= MAX_SKELETONS) return;
            if (Date.now() - lastSkeletonSpawn < SKELETON_SPAWN_INTERVAL) return;
            lastSkeletonSpawn = Date.now();

            let x, y;
            const buildingSize = 192; // Grid-aligned building size
            const buildingHalfSize = buildingSize / 2;
            const worldSize = 1000; // Spawn within 1000 units from center
            const playerSafeDistance = 200; // Safe distance around player

            // Generate random position anywhere in world, but not inside building or near player
            let distToPlayer;
            do {
                x = (Math.random() - 0.5) * worldSize * 2;
                y = (Math.random() - 0.5) * worldSize * 2;
                distToPlayer = Math.sqrt((x - player.x) * (x - player.x) + (y - player.y) * (y - player.y));
            } while ((Math.abs(x) < buildingHalfSize + 50 && Math.abs(y) < buildingHalfSize + 50) ||
                     distToPlayer < playerSafeDistance);

            skeletons.push({
                x, y,
                size: 15,
                speed: Math.random() * 0.5 + 0.5,
                frame: 0,
                lastFrameChange: Date.now(),
                active: false,
                idleDirection: { x: Math.random() * 2 - 1, y: Math.random() * 2 - 1 }
            });
        }
        
        function checkEnemyWallCollision(x, y, radius) {
             for (const wall of walls) {
                const testX = Math.max(wall.x, Math.min(x, wall.x + wall.width));
                const testY = Math.max(wall.y, Math.min(y, wall.y + wall.height));
                const distX = x - testX;
                const distY = y - testY;
                const distance = Math.sqrt((distX * distX) + (distY * distY));
                if (distance <= radius) {
                    return true;
                }
            }
            for (const door of doors) {
                if (door.openAmount < 1) {
                    // Check collision only with visible parts of door panels
                    const halfWidth = door.width * 0.5;
                    const wallGapWidth = (192 - 64) / 2; // Available wall pocket space
                    const maxSlideDistance = Math.min(halfWidth, wallGapWidth); // Don't slide beyond wall pocket
                    const slideDistance = maxSlideDistance * door.openAmount;
                    const panelWidth = halfWidth;

                    let distance = Infinity;

                    if (door.openAmount < 1) {
                        // Left door panel collision - only visible part in doorway
                        const leftPanelX = door.x - slideDistance;
                        const leftVisibleStart = Math.max(door.x, leftPanelX);
                        const leftVisibleEnd = Math.min(door.x + halfWidth, leftPanelX + panelWidth);
                        const leftVisibleWidth = Math.max(0, leftVisibleEnd - leftVisibleStart);

                        if (leftVisibleWidth > 0) {
                            const testXLeft = Math.max(leftVisibleStart, Math.min(x, leftVisibleStart + leftVisibleWidth));
                            const testYLeft = Math.max(door.y, Math.min(y, door.y + door.height));
                            const distXLeft = x - testXLeft;
                            const distYLeft = y - testYLeft;
                            const distanceLeft = Math.sqrt((distXLeft * distXLeft) + (distYLeft * distYLeft));
                            distance = Math.min(distance, distanceLeft);
                        }

                        // Right door panel collision - only visible part in doorway
                        const rightPanelX = door.x + halfWidth + slideDistance;
                        const rightVisibleStart = Math.max(door.x + halfWidth, rightPanelX);
                        const rightVisibleEnd = Math.min(door.x + door.width, rightPanelX + panelWidth);
                        const rightVisibleWidth = Math.max(0, rightVisibleEnd - rightVisibleStart);

                        if (rightVisibleWidth > 0) {
                            const testXRight = Math.max(rightVisibleStart, Math.min(x, rightVisibleStart + rightVisibleWidth));
                            const testYRight = Math.max(door.y, Math.min(y, door.y + door.height));
                            const distXRight = x - testXRight;
                            const distYRight = y - testYRight;
                            const distanceRight = Math.sqrt((distXRight * distXRight) + (distYRight * distYRight));
                            distance = Math.min(distance, distanceRight);
                        }
                    }
                    if (distance <= radius) {
                        return true;
                    }
                }
            }
            return false;
        }

        function updateZombies() {
            zombies.forEach(zombie => {
                const distance = Math.hypot(player.x - zombie.x, player.y - zombie.y);
                if (distance < 200) {
                    zombie.active = true;
                }

                if (zombie.active) {
                    const angle = Math.atan2(player.y - zombie.y, player.x - zombie.x);
                    const dx = Math.cos(angle) * zombie.speed;
                    const dy = Math.sin(angle) * zombie.speed;
                    
                    if (!checkEnemyWallCollision(zombie.x + dx, zombie.y, zombie.size)) {
                        zombie.x += dx;
                    }
                    if (!checkEnemyWallCollision(zombie.x, zombie.y + dy, zombie.size)) {
                        zombie.y += dy;
                    }

                    // Animate zombie
                    if (Date.now() - zombie.lastFrameChange > ZOMBIE_ANIM_SPEED) {
                        zombie.frame = (zombie.frame + 1) % 2; 
                        zombie.lastFrameChange = Date.now();
                    }
                } else {
                    let dx = zombie.idleDirection.x * zombie.speed * 0.5;
                    let dy = zombie.idleDirection.y * zombie.speed * 0.5;
                    
                    // Check for wall collisions in idle state
                    if (checkEnemyWallCollision(zombie.x + dx, zombie.y, zombie.size) || Math.random() < 0.01) {
                         const newAngle = Math.random() * Math.PI * 2;
                         zombie.idleDirection.x = Math.cos(newAngle);
                         zombie.idleDirection.y = Math.sin(newAngle);
                    }
                    if (checkEnemyWallCollision(zombie.x, zombie.y + dy, zombie.size) || Math.random() < 0.01) {
                         const newAngle = Math.random() * Math.PI * 2;
                         zombie.idleDirection.x = Math.cos(newAngle);
                         zombie.idleDirection.y = Math.sin(newAngle);
                    }
                    
                    zombie.x += zombie.idleDirection.x * zombie.speed * 0.5;
                    zombie.y += zombie.idleDirection.y * zombie.speed * 0.5;

                    if (Date.now() - zombie.lastFrameChange > ZOMBIE_ANIM_SPEED) {
                        zombie.frame = (zombie.frame + 1) % 2;
                        zombie.lastFrameChange = Date.now();
                    }
                }
            });
        }
        
        function updateSkeletons() {
            skeletons.forEach(skeleton => {
                const distance = Math.hypot(player.x - skeleton.x, player.y - skeleton.y);
                if (distance < 200) {
                    skeleton.active = true;
                }

                if (skeleton.active) {
                    const angle = Math.atan2(player.y - skeleton.y, player.x - skeleton.x);
                    const dx = Math.cos(angle) * skeleton.speed;
                    const dy = Math.sin(angle) * skeleton.speed;

                    if (!checkEnemyWallCollision(skeleton.x + dx, skeleton.y, skeleton.size)) {
                        skeleton.x += dx;
                    }
                    if (!checkEnemyWallCollision(skeleton.x, skeleton.y + dy, skeleton.size)) {
                        skeleton.y += dy;
                    }
                    // Animate skeleton
                    if (Date.now() - skeleton.lastFrameChange > SKELETON_ANIM_SPEED) {
                        skeleton.frame = (skeleton.frame + 1) % 2;
                        skeleton.lastFrameChange = Date.now();
                    }
                } else {
                    let dx = skeleton.idleDirection.x * skeleton.speed * 0.5;
                    let dy = skeleton.idleDirection.y * skeleton.speed * 0.5;
                    
                    if (checkEnemyWallCollision(skeleton.x + dx, skeleton.y, skeleton.size) || Math.random() < 0.01) {
                        const newAngle = Math.random() * Math.PI * 2;
                        skeleton.idleDirection.x = Math.cos(newAngle);
                        skeleton.idleDirection.y = Math.sin(newAngle);
                    }
                    if (checkEnemyWallCollision(skeleton.x, skeleton.y + dy, skeleton.size) || Math.random() < 0.01) {
                        const newAngle = Math.random() * Math.PI * 2;
                        skeleton.idleDirection.x = Math.cos(newAngle);
                        skeleton.idleDirection.y = Math.sin(newAngle);
                    }
                    
                    skeleton.x += skeleton.idleDirection.x * skeleton.speed * 0.5;
                    skeleton.y += skeleton.idleDirection.y * skeleton.speed * 0.5;
                    
                    if (Date.now() - skeleton.lastFrameChange > SKELETON_ANIM_SPEED) {
                        skeleton.frame = (skeleton.frame + 1) % 2;
                        skeleton.lastFrameChange = Date.now();
                    }
                }
            });
        }
        
        function drawZombies() {
            zombies.forEach(zombie => {
                drawZombieFrame(zombie.x, zombie.y, zombie.frame);
            });
        }
        
        function drawZombieFrame(x, y, frame) {
            const size = 3;
            const bodyColor = '#8b5e2f'; 
            const mouthColor = '#000000';
            const teethColor = '#ffffff';
            const skinColor = '#724f2b';
            const eyeColor = '#3c6e4e';

            // Head
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 4 * size, y - 5 * size, 8 * size, 6 * size);
            
            // Mouth
            ctx.fillStyle = mouthColor;
            ctx.fillRect(x - 3 * size, y, 6 * size, 3 * size);

            // Teeth
            ctx.fillStyle = teethColor;
            ctx.fillRect(x - 3 * size, y, 2 * size, size);
            ctx.fillRect(x + size, y, 2 * size, size);
            ctx.fillRect(x - 2 * size, y + size, 2 * size, size);
            ctx.fillRect(x, y + size, 2 * size, size);

            // Eyes
            ctx.fillStyle = eyeColor;
            ctx.fillRect(x - 3 * size, y - 4 * size, 2 * size, 2 * size);
            ctx.fillRect(x + size, y - 4 * size, 2 * size, 2 * size);

            // Body
            ctx.fillStyle = '#4b6e5b';
            ctx.fillRect(x - 4 * size, y + 2 * size, 8 * size, 6 * size);

            // Arms
            const armOffset = frame === 0 ? 3 * size : -3 * size;
            ctx.fillStyle = skinColor;
            ctx.fillRect(x - 6 * size, y + 2 * size + armOffset, 2 * size, 4 * size);
            ctx.fillRect(x + 4 * size, y + 2 * size - armOffset, 2 * size, 4 * size);

            // Legs
            const legOffset = frame === 0 ? size : -size;
            ctx.fillStyle = bodyColor;
            ctx.fillRect(x - 4 * size, y + 8 * size + legOffset, 3 * size, 4 * size);
            ctx.fillRect(x + size, y + 8 * size - legOffset, 3 * size, 4 * size);
        }
        
        function drawSkeletons() {
            skeletons.forEach(skeleton => {
                drawSkeletonFrame(skeleton.x, skeleton.y, skeleton.frame);
            });
        }

        function drawSkeletonFrame(x, y, frame) {
            const size = 3;
            const boneColor = '#ffffff';
            const eyeColor = '#000000';

            // Head (Skull)
            ctx.fillStyle = boneColor;
            ctx.fillRect(x - 3 * size, y - 6 * size, 6 * size, 6 * size);
            
            // Eye sockets
            ctx.fillStyle = eyeColor;
            ctx.fillRect(x - 2 * size, y - 4 * size, size, size);
            ctx.fillRect(x + size, y - 4 * size, size, size);

            // Nose
            ctx.fillRect(x - size / 2, y - 2 * size, size, size);
            
            // Teeth
            ctx.fillStyle = boneColor;
            ctx.fillRect(x - 2 * size, y - size, 4 * size, size);

            // Body
            ctx.fillStyle = boneColor;
            ctx.fillRect(x - 2 * size, y, 4 * size, 8 * size);

            // Arms
            const armOffset = frame === 0 ? 3 * size : -3 * size;
            ctx.fillRect(x - 5 * size, y + size + armOffset, 2 * size, 6 * size);
            ctx.fillRect(x + 3 * size, y + size - armOffset, 2 * size, 6 * size);

            // Legs
            const legOffset = frame === 0 ? size : -size;
            ctx.fillRect(x - 2 * size, y + 8 * size + legOffset, 2 * size, 6 * size);
            ctx.fillRect(x + size, y + 8 * size - legOffset, 2 * size, 6 * size);
        }

        function createMuzzleFlash(x, y, angle, weaponType) {
            const flashSize = {
                pistol: 20,
                shotgun: 35,
                fragGrenade: 40,
                nuke: 60,
                missile: 30
            };

            const flashDuration = {
                pistol: 80,
                shotgun: 120,
                fragGrenade: 150,
                nuke: 250,
                missile: 150
            };

            const flashColor = {
                pistol: '#ffff99',
                shotgun: '#ffaa00',
                fragGrenade: '#ff6600',
                nuke: '#ff0000',
                missile: '#99ccff'
            };

            // Create multiple flash particles for more realistic effect
            const particleCount = weaponType === 'shotgun' ? 8 : 5;

            for (let i = 0; i < particleCount; i++) {
                const spread = weaponType === 'shotgun' ? 0.3 : 0.2;
                const particleAngle = angle + (Math.random() - 0.5) * spread;
                const distance = Math.random() * flashSize[weaponType] + 10;

                muzzleFlashes.push({
                    x: x + Math.cos(particleAngle) * distance * 0.3,
                    y: y + Math.sin(particleAngle) * distance * 0.3,
                    radius: Math.random() * flashSize[weaponType] * 0.5 + flashSize[weaponType] * 0.3,
                    maxRadius: flashSize[weaponType],
                    life: flashDuration[weaponType],
                    maxLife: flashDuration[weaponType],
                    color: flashColor[weaponType],
                    angle: particleAngle,
                    speed: Math.random() * 2 + 1
                });
            }

            // Add a bright center flash
            muzzleFlashes.push({
                x: x + Math.cos(angle) * 15,
                y: y + Math.sin(angle) * 15,
                radius: flashSize[weaponType] * 0.7,
                maxRadius: flashSize[weaponType],
                life: flashDuration[weaponType],
                maxLife: flashDuration[weaponType],
                color: '#ffffff',
                angle: angle,
                speed: 0
            });
        }

        function updateMuzzleFlashes() {
            muzzleFlashes.forEach(flash => {
                flash.life -= 16; // Decrease by 16ms per frame (assuming 60fps)
                flash.radius *= 0.95; // Shrink slightly

                // Move flash particles outward slightly
                flash.x += Math.cos(flash.angle) * flash.speed;
                flash.y += Math.sin(flash.angle) * flash.speed;
                flash.speed *= 0.9; // Slow down
            });

            // Remove expired flashes
            muzzleFlashes = muzzleFlashes.filter(flash => flash.life > 0);
        }

        function drawMuzzleFlashes() {
            muzzleFlashes.forEach(flash => {
                const alpha = flash.life / flash.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.shadowBlur = 20;
                ctx.shadowColor = flash.color;
                ctx.fillStyle = flash.color;
                ctx.beginPath();
                ctx.arc(flash.x, flash.y, flash.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        function createBloodSplatter(x, y, bulletAngle, isHeadshot = false) {
            const particleCount = isHeadshot ? 12 : 8;
            const intensity = isHeadshot ? 1.5 : 1.0;

            for (let i = 0; i < particleCount; i++) {
                const spread = Math.PI / 3; // 60 degree spread
                const angle = bulletAngle + (Math.random() - 0.5) * spread;
                const speed = Math.random() * 4 * intensity + 2 * intensity;
                const size = Math.random() * 4 + 2;

                // Blood colors - mix of reds and darker reds
                const bloodColors = ['#cc0000', '#990000', '#660000', '#aa0000', '#880000'];
                const color = bloodColors[Math.floor(Math.random() * bloodColors.length)];

                bloodSplatters.push({
                    x: x,
                    y: y,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    radius: size,
                    originalRadius: size,
                    life: 300 + Math.random() * 200, // 300-500ms life
                    maxLife: 300 + Math.random() * 200,
                    color: color,
                    gravity: 0.1,
                    bounce: 0.3,
                    type: 'blood'
                });
            }
        }

        function createDustSplatter(x, y, bulletAngle, isHeadshot = false) {
            const particleCount = isHeadshot ? 12 : 8;
            const intensity = isHeadshot ? 1.5 : 1.0;

            for (let i = 0; i < particleCount; i++) {
                const spread = Math.PI / 3; // 60 degree spread
                const angle = bulletAngle + (Math.random() - 0.5) * spread;
                const speed = Math.random() * 3 * intensity + 1.5 * intensity;
                const size = Math.random() * 3 + 1.5;

                // Dust/bone colors - grays, whites, and off-whites
                const dustColors = ['#cccccc', '#ffffff', '#dddddd', '#aaaaaa', '#e0e0e0', '#f5f5f5'];
                const color = dustColors[Math.floor(Math.random() * dustColors.length)];

                bloodSplatters.push({
                    x: x,
                    y: y,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    radius: size,
                    originalRadius: size,
                    life: 400 + Math.random() * 300, // 400-700ms life (dust lingers longer)
                    maxLife: 400 + Math.random() * 300,
                    color: color,
                    gravity: 0.05, // Less gravity for dust
                    bounce: 0.1, // Less bouncy
                    type: 'dust'
                });
            }
        }

        function updateBloodSplatters() {
            bloodSplatters.forEach(splatter => {
                splatter.life -= 16; // Decrease by 16ms per frame

                // Apply velocity
                splatter.x += splatter.dx;
                splatter.y += splatter.dy;

                // Apply gravity
                splatter.dy += splatter.gravity;

                // Apply air resistance
                splatter.dx *= 0.98;
                splatter.dy *= 0.98;

                // Bounce off walls
                if (checkWallCollision(splatter.x, splatter.y, splatter.radius)) {
                    splatter.dx *= -splatter.bounce;
                    splatter.dy *= -splatter.bounce;
                }

                // Shrink over time
                const ageRatio = 1 - (splatter.life / splatter.maxLife);
                splatter.radius = splatter.originalRadius * (1 - ageRatio * 0.5);
            });

            // Remove expired splatters
            bloodSplatters = bloodSplatters.filter(splatter => splatter.life > 0);
        }

        function drawBloodSplatters() {
            bloodSplatters.forEach(splatter => {
                const alpha = splatter.life / splatter.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = splatter.color;
                ctx.beginPath();
                ctx.arc(splatter.x, splatter.y, splatter.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        function addScreenShake(intensity, duration) {
            // Only add shake if new shake is stronger or current is almost done
            if (intensity > screenShake.intensity || screenShake.duration < 50) {
                screenShake.intensity = intensity;
                screenShake.duration = duration;
            }
        }

        function updateScreenShake() {
            if (screenShake.duration > 0) {
                screenShake.duration -= 16; // Decrease by 16ms per frame

                // Calculate shake offset
                const shakeAmount = screenShake.intensity * (screenShake.duration / 300); // Fade out over time
                screenShake.x = (Math.random() - 0.5) * shakeAmount * 2;
                screenShake.y = (Math.random() - 0.5) * shakeAmount * 2;
            } else {
                screenShake.intensity = 0;
                screenShake.x = 0;
                screenShake.y = 0;
            }
        }

        function createDamageNumber(x, y, damage, isHeadshot = false, enemyType = 'zombie') {
            let color, text;

            if (enemyType === 'loot') {
                // Special colors for loot text
                if (damage.includes('HEALTH')) {
                    color = '#00ff00'; // Green for health
                } else if (damage.includes('AMMO')) {
                    color = '#ffaa00'; // Orange for ammo
                } else if (damage.includes('SPEED')) {
                    color = '#00ccff'; // Cyan for speed
                } else if (damage.includes('DAMAGE')) {
                    color = '#ff4444'; // Red for damage multiplier
                } else if (damage.includes('SHIELD')) {
                    color = '#ffff00'; // Yellow for shield
                } else if (damage.includes('MULTI') || damage.includes('RAPID')) {
                    color = '#ff00ff'; // Magenta for special weapons
                } else {
                    color = '#FFD700'; // Gold for XP bonus
                }
                text = damage;
            } else if (isHeadshot) {
                if (enemyType === 'zombie') {
                    color = '#ffff00'; // Bright yellow for zombie headshots
                    text = damage.toString().startsWith('+') ? damage : `+${damage}`;
                } else {
                    color = '#ffffff'; // White for skeleton headshots
                    text = damage.toString().startsWith('+') ? damage : `+${damage}`;
                }
            } else {
                if (enemyType === 'zombie') {
                    color = '#ffffff'; // White for zombie body shots
                    text = damage.toString().startsWith('+') ? damage : `+${damage}`;
                } else {
                    color = '#cccccc'; // Gray for skeleton body shots
                    text = damage.toString().startsWith('+') ? damage : `+${damage}`;
                }
            }

            damageNumbers.push({
                x: x + (Math.random() - 0.5) * 20, // Slight random offset
                y: y,
                text: text,
                color: color,
                life: 1000, // 1 second lifespan
                maxLife: 1000,
                fontSize: isHeadshot ? 18 : 14,
                velocity: {
                    x: (Math.random() - 0.5) * 2,
                    y: -2 - Math.random() * 2 // Float upward
                }
            });
        }

        function updateDamageNumbers() {
            damageNumbers.forEach(number => {
                number.life -= 16; // Decrease by 16ms per frame

                // Move the number
                number.x += number.velocity.x;
                number.y += number.velocity.y;

                // Apply slight gravity and air resistance
                number.velocity.y += 0.05;
                number.velocity.x *= 0.98;

                // Increase font size slightly at first, then shrink
                const ageRatio = 1 - (number.life / number.maxLife);
                if (ageRatio < 0.2) {
                    number.fontSize += 0.3; // Grow in first 20% of life
                } else {
                    number.fontSize *= 0.99; // Shrink after that
                }
            });

            // Remove expired numbers
            damageNumbers = damageNumbers.filter(number => number.life > 0);
        }

        function drawDamageNumbers() {
            damageNumbers.forEach(number => {
                const alpha = number.life / number.maxLife;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = number.color;
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.font = `bold ${number.fontSize}px "Press Start 2P"`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Draw text outline for better visibility
                ctx.strokeText(number.text, number.x, number.y);
                ctx.fillText(number.text, number.x, number.y);

                ctx.restore();
            });
        }

        function shoot(targetX, targetY) {
            if (isGameOver) return;

            // Set shooting state for animation
            player.isShooting = true;
            player.shootingEndTime = Date.now() + 300; // 300ms shooting pose

            let dx, dy;
            // Priority: gamepad aim > mouse (only if not using gamepad) > movement direction
            if (gamepad && (gamepadAimX !== 0 || gamepadAimY !== 0)) {
                // Use gamepad aim direction
                dx = gamepadAimX * GAMEPAD_AIM_SENSITIVITY;
                dy = gamepadAimY * GAMEPAD_AIM_SENSITIVITY;
            } else if (!gamepad && mouseMoved) {
                // Use mouse direction only when not using gamepad
                dx = mouseX - player.x;
                dy = mouseY - player.y;
            } else {
                // Default to character movement direction
                dx = playerDirection.x;
                dy = playerDirection.y;
            }

            const angle = Math.atan2(dy, dx);
            const magnitude = Math.hypot(dx, dy);

            console.log('SHOOT: dx:', dx, 'dy:', dy, 'magnitude:', magnitude, 'weapon:', currentWeapon);
            if (magnitude === 0) {
                console.log('SHOOT: Magnitude is 0, returning');
                return;
            }

            if (currentWeapon === 'axe') {
                // Melee axe swing - check for trees in range
                const swingRange = 40; // Axe swing range
                audioManager.playSound('axeChop'); // Realistic wood chopping sound
                vibrateGamepad(0.2, 0.4, 200); // Medium vibration for axe swing

                // Check for trees within swing range
                if (window.gameObjects && window.gameObjects.trees) {
                    window.gameObjects.trees.forEach((tree, index) => {
                        const distance = Math.hypot(player.x - tree.collision.centerX, player.y - tree.collision.centerY);
                        if (distance <= swingRange) {
                            // Damage the tree
                            tree.collision.health -= 25; // 4 hits to destroy
                            console.log(`Hit tree! Health: ${tree.collision.health}/${tree.collision.maxHealth}`);

                            if (tree.collision.health <= 0) {
                                // Tree destroyed - create wood planks
                                createWoodPlanks(tree.collision.centerX, tree.collision.centerY, 3);
                                // Remove tree from array
                                window.gameObjects.trees.splice(index, 1);
                                console.log('Tree destroyed! Wood planks created.');
                            }
                        }
                    });
                }
            } else if (currentWeapon === 'pickaxe') {
                // Melee pickaxe swing - check for rocks in range
                const swingRange = 40; // Pickaxe swing range
                audioManager.playSound('axeChop'); // Reuse axe sound for now - could create rock mining sound later
                vibrateGamepad(0.3, 0.5, 250); // Slightly stronger vibration for pickaxe

                // Check for rocks within swing range
                if (window.gameObjects && window.gameObjects.rocks) {
                    window.gameObjects.rocks.forEach((rock, index) => {
                        const distance = Math.hypot(player.x - rock.collision.centerX, player.y - rock.collision.centerY);
                        if (distance <= swingRange) {
                            // Damage the rock
                            rock.collision.health -= 30; // 5 hits to destroy (rocks are tougher)
                            console.log(`Hit rock! Health: ${rock.collision.health}/${rock.collision.maxHealth}`);

                            if (rock.collision.health <= 0) {
                                // Rock destroyed - create stone pieces
                                createStone(rock.collision.centerX, rock.collision.centerY, 4);
                                // Remove rock from array
                                window.gameObjects.rocks.splice(index, 1);
                                console.log('Rock destroyed! Stone pieces created.');
                            }
                        }
                    });
                }
            } else if (currentWeapon === 'pistol') {
                if (ammo.pistol <= 0) return;
                ammo.pistol--;
                audioManager.playSound('pistol');
                createMuzzleFlash(player.x, player.y, angle, 'pistol');
                vibrateGamepad(0.1, 0.2, 100); // Light vibration for pistol
                const speed = 10;
                playerBullets.push({
                    x: player.x,
                    y: player.y,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    radius: 4,
                    color: '#ffdd4d'
                });
            } else if (currentWeapon === 'shotgun') {
                if (ammo.shotgun <= 0) return;
                ammo.shotgun--;
                audioManager.playSound('shotgun');
                createMuzzleFlash(player.x, player.y, angle, 'shotgun');
                addScreenShake(3, 100); // Subtle shake for shotgun recoil
                vibrateGamepad(0.3, 0.6, 150); // Strong vibration for shotgun
                const speed = 8;
                const spreadAngle = Math.PI / 16;
                for (let i = -2; i <= 2; i++) {
                    const newAngle = angle + (i * spreadAngle);
                    playerBullets.push({
                        x: player.x,
                        y: player.y,
                        dx: Math.cos(newAngle) * speed,
                        dy: Math.sin(newAngle) * speed,
                        radius: 3,
                        color: '#ffdd4d'
                    });
                }
            } else if (currentWeapon === 'assaultRifle') {
                if (ammo.assaultRifle <= 0) return;
                ammo.assaultRifle--;
                audioManager.playSound('assaultRifle');
                createMuzzleFlash(player.x, player.y, angle, 'assaultRifle');
                addScreenShake(2, 50); // Light shake for assault rifle
                vibrateGamepad(0.15, 0.25, 80); // Rapid light vibration for assault rifle
                const speed = 12;
                playerBullets.push({
                    x: player.x,
                    y: player.y,
                    dx: Math.cos(angle) * speed,
                    dy: Math.sin(angle) * speed,
                    radius: 3,
                    color: '#ff8844'
                });
            } else if (currentWeapon === 'fragGrenade') {
                if (ammo.fragGrenade <= 0) return;
                ammo.fragGrenade--;
                audioManager.playSound('fragGrenade');
                createMuzzleFlash(player.x, player.y, angle, 'fragGrenade');
                addScreenShake(8, 200); // Medium shake for frag grenade
                vibrateGamepad(0.4, 0.7, 250); // Strong explosion vibration

                // Create 20 lethal fragments in all directions
                const speed = 12;
                for (let i = 0; i < 20; i++) {
                    const fragmentAngle = (Math.PI * 2 * i) / 20; // Evenly distributed
                    fragments.push({
                        x: player.x,
                        y: player.y,
                        dx: Math.cos(fragmentAngle) * speed,
                        dy: Math.sin(fragmentAngle) * speed,
                        radius: 2,
                        color: '#ff6666',
                        life: 60 // Fragments last 1 second at 60fps
                    });
                }
            } else if (currentWeapon === 'nuke') {
                if (ammo.nuke <= 0) return;
                ammo.nuke--;
                audioManager.playSound('nuke');
                createMuzzleFlash(player.x, player.y, angle, 'nuke');
                addScreenShake(15, 400); // Strong shake for nuke
                vibrateGamepad(0.8, 1.0, 500); // Maximum nuclear explosion vibration

                // Calculate nuke target position based on aim direction
                const nukeRange = 200; // Distance from player
                const nukeTargetX = player.x + Math.cos(angle) * nukeRange;
                const nukeTargetY = player.y + Math.sin(angle) * nukeRange;

                explosions.push({
                    x: nukeTargetX,
                    y: nukeTargetY,
                    radius: 0,
                    maxRadius: 150,
                    life: 1,
                    particles: []
                });

                // Award XP for nuke kills
                awardXP(zombies.length * 1); // 1 XP per zombie
                zombies = [];
                awardXP(skeletons.length * 2); // 2 XP per skeleton
                skeletons = [];

                // Destroy all chests in nuke blast
                if (chests.length > 0) {
                    // Create debris effects for destroyed chests
                    chests.forEach(chest => {
                        // Create small explosion for each chest
                        explosions.push({
                            x: chest.x,
                            y: chest.y,
                            radius: 0,
                            maxRadius: 30,
                            life: 1,
                            particles: []
                        });

                        // Create debris fragments
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI * 2 * i) / 6;
                            const speed = Math.random() * 4 + 3;
                            fragments.push({
                                x: chest.x,
                                y: chest.y,
                                dx: Math.cos(angle) * speed,
                                dy: Math.sin(angle) * speed,
                                radius: 2,
                                color: '#8B4513',
                                life: 40
                            });
                        }
                    });

                    // Clear all chests
                    chests = [];
                }
            } else if (currentWeapon === 'missile') {
                if (ammo.missile <= 0) return;
                ammo.missile--;
                audioManager.playSound('missile');
                createMuzzleFlash(player.x, player.y, angle, 'missile');
                if (zombies.length > 0) {
                    let targetZombie = null;
                    let minDistance = Infinity;
                    zombies.forEach(zombie => {
                        const distance = Math.hypot(player.x - zombie.x, player.y - zombie.y);
                        if (distance < minDistance) {
                            minDistance = distance;
                            targetZombie = zombie;
                        }
                    });

                    if (targetZombie) {
                        missiles.push({
                            x: player.x,
                            y: player.y,
                            speed: 4,
                            radius: 8,
                            color: '#e6e6e6',
                            target: targetZombie,
                            hit: false
                        });
                    }
                }
            }
            updateAmmoDisplay();
        }

        function updatePlayerBullets() {
            playerBullets.forEach(bullet => {
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;
            });
            // Filter bullets based on distance from camera (much larger range for camera system)
            const maxDistance = 2000; // Large range so bullets can travel far from view
            playerBullets = playerBullets.filter(bullet => {
                const dx = bullet.x - camera.x;
                const dy = bullet.y - camera.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < maxDistance;
            });
        }
        
        function updateEnemyBullets() {
            enemyBullets.forEach(bullet => {
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;
            });
            // Filter enemy bullets based on distance from camera
            const maxDistance = 2000; // Large range so bullets can travel far from view
            enemyBullets = enemyBullets.filter(bullet => {
                const dx = bullet.x - camera.x;
                const dy = bullet.y - camera.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < maxDistance;
            });
        }

        function drawBullets() {
            playerBullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fillStyle = bullet.color;
                ctx.fill();
            });
            enemyBullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                ctx.fillStyle = bullet.color;
                ctx.fill();
            });
        }
        
        function updateMissiles() {
            missiles.forEach(missile => {
                if (missile.target) {
                    const angle = Math.atan2(missile.target.y - missile.y, missile.target.x - missile.x);
                    missile.x += Math.cos(angle) * missile.speed;
                    missile.y += Math.sin(angle) * missile.speed;
                }
            });
        }

        function drawMissiles() {
            missiles.forEach(missile => {
                ctx.beginPath();
                ctx.arc(missile.x, missile.y, missile.radius, 0, Math.PI * 2);
                ctx.fillStyle = missile.color;
                ctx.fill();
            });
        }

        function updateFragments() {
            fragments.forEach(fragment => {
                fragment.x += fragment.dx;
                fragment.y += fragment.dy;
                fragment.life--;
            });
            // Filter fragments based on distance from camera and life
            const maxDistance = 2000;
            fragments = fragments.filter(fragment => {
                if (fragment.life <= 0) return false;

                const dx = fragment.x - camera.x;
                const dy = fragment.y - camera.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < maxDistance;
            });
        }

        function drawFragments() {
            fragments.forEach(fragment => {
                ctx.beginPath();
                ctx.arc(fragment.x, fragment.y, fragment.radius, 0, Math.PI * 2);
                ctx.fillStyle = fragment.color;
                ctx.fill();
            });
        }

        function updateExplosions() {
            explosions.forEach(explosion => {
                explosion.radius += 5;
                if (explosion.radius > explosion.maxRadius) {
                    explosion.life -= 0.05;
                }
                
                for (let i = 0; i < 5; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 1;
                    const color = Math.random() > 0.5 ? '#ff4500' : '#ffa500';
                    explosion.particles.push({
                        x: explosion.x,
                        y: explosion.y,
                        dx: Math.cos(angle) * speed,
                        dy: Math.sin(angle) * speed,
                        radius: 3,
                        life: 1,
                        color: color
                    });
                }
                
                explosion.particles.forEach(particle => {
                    particle.x += particle.dx;
                    particle.y += particle.dy;
                    particle.life -= 0.02;
                    particle.radius *= 0.98;
                });

                explosion.particles = explosion.particles.filter(p => p.life > 0);
            });
            
            explosions = explosions.filter(e => e.life > 0);
        }

        function drawExplosions() {
            explosions.forEach(explosion => {
                ctx.save();
                ctx.globalAlpha = explosion.life;
                ctx.fillStyle = '#ff4500';
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                explosion.particles.forEach(particle => {
                    ctx.save();
                    ctx.globalAlpha = particle.life;
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            });
        }
        
        function spawnChest() {
            if (Date.now() - lastChestSpawn < CHEST_SPAWN_INTERVAL) return;
            if (chests.length > 0) return; // Only allow one chest at a time
            lastChestSpawn = Date.now();

            let x, y;
            let attempt = 0;
            do {
                x = Math.random() * (canvas.width - 50) + 25;
                y = Math.random() * (canvas.height - 50) + 25;
                attempt++;
            } while (checkWallCollision(x, y, 20) && attempt < 100);

            if (attempt < 100) {
                chests.push({
                    x, y,
                    size: 20,
                    color: '#8b4513'
                });
            }
        }

        function drawChests() {
            chests.forEach(chest => {
                ctx.fillStyle = chest.color;
                ctx.fillRect(chest.x - chest.size/2, chest.y - chest.size/2, chest.size, chest.size);
                
                ctx.fillStyle = '#ffc107';
                ctx.font = '16px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('?', chest.x, chest.y);
            });
        }

        function checkCollisions() {
            const size = 3;
            // Player bullets vs enemies
            playerBullets.forEach((bullet, bIndex) => {
                // Check against zombies
                zombies.forEach((zombie, zIndex) => {
                    const headshotX = bullet.x > zombie.x - 4 * size && bullet.x < zombie.x + 4 * size;
                    const headshotY = bullet.y > zombie.y - 5 * size && bullet.y < zombie.y + size;
                    
                    const distance = Math.hypot(bullet.x - zombie.x, bullet.y - (zombie.y + 2 * size));

                    if (headshotX && headshotY) {
                         setTimeout(() => {
                            const bulletAngle = Math.atan2(bullet.dy, bullet.dx);
                            createBloodSplatter(zombie.x, zombie.y - 10, bulletAngle, true);
                            createDamageNumber(zombie.x, zombie.y - 20, '+3 XP', true, 'zombie');
                            playerBullets.splice(bIndex, 1);
                            zombies.splice(zIndex, 1);
                            audioManager.playSound('zombieDeath');
                            awardXP(3); // Zombie headshot XP
                        }, 0);
                        return; // Prevent body shot from also triggering
                    } else if (distance < bullet.radius + 12) {
                        setTimeout(() => {
                            const bulletAngle = Math.atan2(bullet.dy, bullet.dx);
                            createBloodSplatter(zombie.x, zombie.y, bulletAngle, false);
                            createDamageNumber(zombie.x, zombie.y - 10, '+1 XP', false, 'zombie');
                            playerBullets.splice(bIndex, 1);
                            zombies.splice(zIndex, 1);
                            audioManager.playSound('zombieDeath');
                            awardXP(1); // Regular zombie XP
                        }, 0);
                    }
                });
                
                // Check against skeletons
                skeletons.forEach((skeleton, sIndex) => {
                    const headshotX = bullet.x > skeleton.x - 3 * size && bullet.x < skeleton.x + 3 * size;
                    const headshotY = bullet.y > skeleton.y - 6 * size && bullet.y < skeleton.y;

                    const distance = Math.hypot(bullet.x - skeleton.x, bullet.y - skeleton.y);

                    if (headshotX && headshotY) {
                         setTimeout(() => {
                            const bulletAngle = Math.atan2(bullet.dy, bullet.dx);
                            createDustSplatter(skeleton.x, skeleton.y - 10, bulletAngle, true);
                            createDamageNumber(skeleton.x, skeleton.y - 20, '+5 XP', true, 'skeleton');
                            playerBullets.splice(bIndex, 1);
                            skeletons.splice(sIndex, 1);
                            audioManager.playSound('skeletonDeath');
                            awardXP(5); // Skeleton headshot XP
                        }, 0);
                        return; // Prevent body shot from also triggering
                    } else if (distance < bullet.radius + skeleton.size) {
                         setTimeout(() => {
                            const bulletAngle = Math.atan2(bullet.dy, bullet.dx);
                            createDustSplatter(skeleton.x, skeleton.y, bulletAngle, false);
                            createDamageNumber(skeleton.x, skeleton.y - 10, '+2 XP', false, 'skeleton');
                            playerBullets.splice(bIndex, 1);
                            skeletons.splice(sIndex, 1);
                            audioManager.playSound('skeletonDeath');
                            awardXP(2); // Regular skeleton XP
                        }, 0);
                    }
                });
                
                // Check against walls
                if (checkWallCollision(bullet.x, bullet.y, bullet.radius)) {
                    setTimeout(() => {
                        playerBullets.splice(bIndex, 1);
                    }, 0);
                }

                // Check against chests - destroy chest if shot
                chests.forEach((chest, cIndex) => {
                    const distance = Math.hypot(bullet.x - chest.x, bullet.y - chest.y);
                    if (distance < bullet.radius + chest.size / 2) {
                        setTimeout(() => {
                            // Create explosion effect
                            explosions.push({
                                x: chest.x,
                                y: chest.y,
                                radius: 0,
                                maxRadius: 50,
                                life: 1,
                                particles: []
                            });

                            // Create dust/debris effect
                            for (let i = 0; i < 8; i++) {
                                const angle = (Math.PI * 2 * i) / 8;
                                const speed = Math.random() * 3 + 2;
                                fragments.push({
                                    x: chest.x,
                                    y: chest.y,
                                    dx: Math.cos(angle) * speed,
                                    dy: Math.sin(angle) * speed,
                                    radius: 2,
                                    color: '#8B4513',
                                    life: 30
                                });
                            }

                            // Screen shake and sound
                            addScreenShake(5, 150);
                            audioManager.playSound('fragGrenade');

                            // Remove bullet and chest
                            playerBullets.splice(bIndex, 1);
                            chests.splice(cIndex, 1);
                        }, 0);
                    }
                });
            });
            
            // Missile vs enemies
            missiles.forEach((missile, mIndex) => {
                zombies.forEach((zombie, zIndex) => {
                    const distance = Math.hypot(missile.x - zombie.x, missile.y - (zombie.y - 18));
                    if (distance < missile.radius + 12) {
                        missile.hit = true;
                        addScreenShake(10, 250); // Medium shake for missile
                        explosions.push({
                            x: missile.x,
                            y: missile.y,
                            radius: 0,
                            maxRadius: 100,
                            life: 1,
                            particles: []
                        });
                        setTimeout(() => {
                            createBloodSplatter(missile.x, missile.y, Math.random() * Math.PI * 2, false);
                            createDamageNumber(zombie.x, zombie.y - 10, '+2 XP', false, 'zombie');
                            zombies.splice(zIndex, 1);
                            audioManager.playSound('zombieDeath');
                            awardXP(2); // Explosion kill XP
                        }, 0);
                    }
                });
            });
            missiles = missiles.filter(m => !m.hit);

            // Player vs enemies
            zombies.forEach(zombie => {
                const distance = Math.hypot(player.x - zombie.x, player.y - zombie.y);
                if (distance < player.radius + zombie.size) {
                    takeDamage();
                }
            });
            skeletons.forEach(skeleton => {
                 const distance = Math.hypot(player.x - skeleton.x, player.y - skeleton.y);
                 if (distance < player.radius + skeleton.size) {
                    takeDamage();
                 }
            });

            // Player vs enemy bullets
            enemyBullets.forEach(bullet => {
                const distance = Math.hypot(player.x - bullet.x, player.y - bullet.y);
                 if (distance < player.radius + bullet.radius) {
                    takeDamage();
                 }
            });
            
            // Player vs chests
            chests.forEach((chest, cIndex) => {
                const distance = Math.hypot(player.x - chest.x, player.y - chest.y);
                if (distance < player.radius + chest.size / 2) {
                    const lootType = rollLootDrop();
                    applyLoot(lootType);
                    updateAmmoDisplay();
                    chests.splice(cIndex, 1);
                }
            });

            // Player vs wood planks
            if (window.gameObjects && window.gameObjects.woodPlanks) {
                window.gameObjects.woodPlanks.forEach((plank, pIndex) => {
                    if (!plank.collected) {
                        const distance = Math.hypot(player.x - plank.x, player.y - plank.y);
                        if (distance < player.radius + Math.max(plank.width, plank.height) / 2) {
                            // Collect wood plank
                            plank.collected = true;

                            // Add to wood inventory (we'll need to create this system)
                            if (!window.inventory) window.inventory = {};
                            if (!window.inventory.wood) window.inventory.wood = 0;
                            window.inventory.wood += plank.value;

                            // Show collection feedback
                            createDamageNumber(plank.x, plank.y - 20, '+WOOD', false, 'loot');
                            audioManager.playSound('chestPickup');

                            // Remove from array after a delay to allow animation
                            setTimeout(() => {
                                const index = window.gameObjects.woodPlanks.indexOf(plank);
                                if (index > -1) {
                                    window.gameObjects.woodPlanks.splice(index, 1);
                                }
                            }, 100);

                            console.log(`Collected wood! Total: ${window.inventory.wood}`);
                        }
                    }
                });
            }

            // Player vs stone pieces
            if (window.gameObjects && window.gameObjects.stone) {
                window.gameObjects.stone.forEach((stone, sIndex) => {
                    if (!stone.collected) {
                        const distance = Math.hypot(player.x - stone.x, player.y - stone.y);
                        if (distance < player.radius + Math.max(stone.width, stone.height) / 2) {
                            // Collect stone piece
                            stone.collected = true;

                            // Add to stone inventory
                            if (!window.inventory) window.inventory = {};
                            if (!window.inventory.stone) window.inventory.stone = 0;
                            window.inventory.stone += stone.value;

                            // Show collection feedback
                            createDamageNumber(stone.x, stone.y - 20, '+STONE', false, 'loot');
                            audioManager.playSound('chestPickup');

                            // Remove from array after a delay to allow animation
                            setTimeout(() => {
                                const index = window.gameObjects.stone.indexOf(stone);
                                if (index > -1) {
                                    window.gameObjects.stone.splice(index, 1);
                                }
                            }, 100);

                            console.log(`Collected stone! Total: ${window.inventory.stone}`);
                        }
                    }
                });
            }

            // Fragment vs enemies collision
            fragments.forEach((fragment, fIndex) => {
                // Check against zombies
                zombies.forEach((zombie, zIndex) => {
                    const distance = Math.hypot(fragment.x - zombie.x, fragment.y - zombie.y);
                    if (distance < fragment.radius + 12) {
                        setTimeout(() => {
                            const fragmentAngle = Math.atan2(fragment.dy, fragment.dx);
                            createBloodSplatter(zombie.x, zombie.y, fragmentAngle, false);
                            createDamageNumber(zombie.x, zombie.y - 10, '+2 XP', false, 'zombie');
                            fragments.splice(fIndex, 1);
                            zombies.splice(zIndex, 1);
                            audioManager.playSound('zombieDeath');
                            awardXP(2); // Explosion kill XP
                        }, 0);
                    }
                });

                // Check against skeletons
                skeletons.forEach((skeleton, sIndex) => {
                    const distance = Math.hypot(fragment.x - skeleton.x, fragment.y - skeleton.y);
                    if (distance < fragment.radius + 12) {
                        setTimeout(() => {
                            const fragmentAngle = Math.atan2(fragment.dy, fragment.dx);
                            createBloodSplatter(skeleton.x, skeleton.y, fragmentAngle, false, 'dust');
                            createDamageNumber(skeleton.x, skeleton.y - 10, '+2 XP', false, 'skeleton');
                            fragments.splice(fIndex, 1);
                            skeletons.splice(sIndex, 1);
                            audioManager.playSound('skeletonDeath');
                            awardXP(2); // Explosion kill XP
                        }, 0);
                    }
                });
            });
        }

        function endGame() {
            isGameOver = true;
            cancelAnimationFrame(animationId);
            audioManager.stopBackgroundMusic();
            finalScoreSpan.textContent = `${sessionXP} XP`;

            // Check for and update high session XP
            const newRecord = checkHighSessionXP();
            highScoreSpan.textContent = `${highSessionXP} XP`;

            gameUI.style.display = 'flex';
            gameOverScreen.style.display = 'flex';
            startMenu.style.display = 'none';
        }

        async function startGame() {
            // Initialize audio on first user interaction
            await audioManager.init();
            audioManager.startBackgroundMusic();

            // Request motion permission for mobile devices
            if (isMobile) {
                await requestMotionPermission();
            }

            isGameOver = false;
            isInMenu = false;
            sessionXP = 0; // Reset session XP for new game
            playerHealth = maxHealth;
            invincibilityFrames = 0;
            // Reset all power-ups
            activePowerUps = {
                speedBoost: 0,
                damageMultiplier: 0,
                shield: 0,
                multiShot: 0,
                rapidFire: 0
            };
            zombies = [];
            skeletons = [];
            playerBullets = [];
            enemyBullets = [];
            explosions = [];
            missiles = [];
            chests = [];
            muzzleFlashes = [];
            bloodSplatters = [];
            damageNumbers = [];
            screenShake = { intensity: 0, duration: 0, x: 0, y: 0 };
            ammo = { ...maxAmmo };
            player.x = 0; // Reset to grid-aligned building center
            player.y = 0;
            initializeCamera(); // Reset camera on game restart
            updateSessionXPDisplay();
            highScoreDisplay.textContent = `Best Session: ${highSessionXP} XP`;
            gameUI.style.display = 'none';
            gameOverScreen.style.display = 'none';
            startMenu.style.display = 'none';
            updateAmmoDisplay();
            updateHealthDisplay();
            gameLoop();
        }
        

        function updateWeaponDisplay() {
            if (currentWeapon === 'axe') {
                weaponDisplay.textContent = 'Weapon: Axe (1)';
            } else if (currentWeapon === 'pistol') {
                weaponDisplay.textContent = 'Weapon: Pistol (2)';
            } else if (currentWeapon === 'shotgun') {
                weaponDisplay.textContent = 'Weapon: Shotgun (3)';
            } else if (currentWeapon === 'assaultRifle') {
                weaponDisplay.textContent = 'Weapon: Assault Rifle (4)';
            } else if (currentWeapon === 'fragGrenade') {
                weaponDisplay.textContent = 'Weapon: Frag Grenade (5)';
            } else if (currentWeapon === 'nuke') {
                weaponDisplay.textContent = 'Weapon: Nuke (6)';
            } else if (currentWeapon === 'missile') {
                weaponDisplay.textContent = 'Weapon: Missile (7)';
            }
        }
        
        function updateAmmoDisplay() {
            const currentAmmo = ammo[currentWeapon];
            if (currentWeapon === 'axe') {
                ammoDisplay.textContent = `Ammo: MELEE`;
            } else if (currentWeapon === 'pistol') {
                ammoDisplay.textContent = `Ammo: ∞`;
            } else {
                ammoDisplay.textContent = `Ammo: ${currentAmmo}`;
            }
        }

        function updateHealthDisplay() {
            let hearts = '';
            for (let i = 0; i < maxHealth; i++) {
                if (i < playerHealth) {
                    hearts += '❤️';
                } else {
                    hearts += '🖤'; // Black heart for lost health
                }
            }
            healthDisplay.textContent = hearts;
        }

        function takeDamage() {
            if (playerHealth > 0 && invincibilityFrames <= 0) {
                // Check if shield is active
                if (activePowerUps.shield > 0) {
                    // Shield absorbs the damage
                    activePowerUps.shield = 0;
                    createDamageNumber(player.x, player.y - 30, 'SHIELD BLOCKED!', false, 'loot');
                    audioManager.playSound('playerHit');
                    addScreenShake(4, 100); // Reduced shake for blocked damage
                    vibrateGamepad(0.2, 0.3, 150); // Light vibration for shield block
                    invincibilityFrames = invincibilityDuration;
                    return;
                }

                playerHealth--;
                invincibilityFrames = invincibilityDuration;
                updateHealthDisplay();
                audioManager.playSound('playerHit');
                addScreenShake(8, 200);
                vibrateGamepad(0.5, 0.8, 300); // Strong vibration for taking damage

                // Add visual feedback for taking damage
                addPlayerDamageEffect();

                // Check if player is dead
                if (playerHealth <= 0) {
                    endGame();
                }
            }
        }

        function addPlayerDamageEffect() {
            // Create red damage indicator particles around player
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI * 2 / 8) * i;
                const distance = 25;
                bloodSplatters.push({
                    x: player.x + Math.cos(angle) * distance,
                    y: player.y + Math.sin(angle) * distance,
                    dx: Math.cos(angle) * 3,
                    dy: Math.sin(angle) * 3,
                    radius: 3,
                    originalRadius: 3,
                    life: 200,
                    maxLife: 200,
                    color: '#ff0000',
                    gravity: 0.05,
                    bounce: 0.2,
                    type: 'damage'
                });
            }
        }

        function getLootDropProbabilities() {
            // Dynamic loot probabilities based on session XP
            if (sessionXP < 50) {
                // Early game: mostly ammo and health
                return {
                    [lootTypes.AMMO]: 60,
                    [lootTypes.HEALTH]: 40
                };
            } else if (sessionXP < 150) {
                // Mid game: add power-ups
                return {
                    [lootTypes.AMMO]: 40,
                    [lootTypes.HEALTH]: 30,
                    [lootTypes.SCORE_BONUS]: 10,
                    [lootTypes.SPEED_BOOST]: 10,
                    [lootTypes.SHIELD]: 10
                };
            } else {
                // Late game: more power-ups
                return {
                    [lootTypes.AMMO]: 25,
                    [lootTypes.HEALTH]: 15,
                    [lootTypes.SCORE_BONUS]: 10,
                    [lootTypes.SPEED_BOOST]: 15,
                    [lootTypes.DAMAGE_MULTIPLIER]: 15,
                    [lootTypes.SHIELD]: 10,
                    [lootTypes.MULTI_SHOT]: 5,
                    [lootTypes.RAPID_FIRE]: 5
                };
            }
        }

        function rollLootDrop() {
            const probabilities = getLootDropProbabilities();
            const totalWeight = Object.values(probabilities).reduce((sum, weight) => sum + weight, 0);
            let random = Math.random() * totalWeight;

            for (const [lootType, weight] of Object.entries(probabilities)) {
                random -= weight;
                if (random <= 0) {
                    return lootType;
                }
            }
            return lootTypes.AMMO; // Fallback
        }

        function updatePowerUps() {
            // Decrease all active power-up timers
            Object.keys(activePowerUps).forEach(powerUp => {
                if (activePowerUps[powerUp] > 0) {
                    activePowerUps[powerUp] -= 16; // Decrease by 16ms per frame
                    if (activePowerUps[powerUp] <= 0) {
                        activePowerUps[powerUp] = 0;
                        // Power-up expired, could add visual feedback here
                    }
                }
            });
        }

        function applyLoot(lootType) {
            switch (lootType) {
                case lootTypes.AMMO:
                    ammo = { ...maxAmmo };
                    createDamageNumber(player.x, player.y - 30, 'AMMO!', false, 'loot');
                    audioManager.playSound('chestPickup');
                    break;

                case lootTypes.HEALTH:
                    if (playerHealth < maxHealth) {
                        playerHealth++;
                        updateHealthDisplay();
                        createDamageNumber(player.x, player.y - 30, '+HEALTH', false, 'loot');
                        audioManager.playSound('chestPickup');
                    } else {
                        // Full health, give score bonus instead
                        awardXP(5);
                        createDamageNumber(player.x, player.y - 30, '+5 XP', false, 'loot');
                        audioManager.playSound('chestPickup');
                    }
                    break;

                case lootTypes.SCORE_BONUS:
                    const bonus = Math.random() > 0.5 ? 100 : 50;
                    const xpBonus = Math.floor(bonus / 10);
                    awardXP(xpBonus);
                    createDamageNumber(player.x, player.y - 30, `+${xpBonus} XP`, false, 'loot');
                    audioManager.playSound('chestPickup');
                    break;

                case lootTypes.SPEED_BOOST:
                    activePowerUps.speedBoost = 10000; // 10 seconds
                    createDamageNumber(player.x, player.y - 30, 'SPEED!', false, 'loot');
                    audioManager.playSound('chestPickup');
                    break;

                case lootTypes.DAMAGE_MULTIPLIER:
                    activePowerUps.damageMultiplier = 15000; // 15 seconds
                    createDamageNumber(player.x, player.y - 30, '2X DAMAGE!', false, 'loot');
                    audioManager.playSound('chestPickup');
                    break;

                case lootTypes.SHIELD:
                    activePowerUps.shield = 30000; // 30 seconds or until hit
                    createDamageNumber(player.x, player.y - 30, 'SHIELD!', false, 'loot');
                    audioManager.playSound('chestPickup');
                    break;

                case lootTypes.MULTI_SHOT:
                    activePowerUps.multiShot = 20000; // 20 seconds
                    createDamageNumber(player.x, player.y - 30, 'MULTI-SHOT!', false, 'loot');
                    audioManager.playSound('chestPickup');
                    break;

                case lootTypes.RAPID_FIRE:
                    activePowerUps.rapidFire = 15000; // 15 seconds
                    createDamageNumber(player.x, player.y - 30, 'RAPID FIRE!', false, 'loot');
                    audioManager.playSound('chestPickup');
                    break;
            }
        }

        function gameLoop() {
            // Handle menu input when in menu
            if (isInMenu) {
                handleMenuInput();
                requestAnimationFrame(gameLoop); // Keep loop running in menu
                return;
            }

            if (isGameOver) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update camera to follow player
            updateCamera();

            // Save canvas state and apply camera transformation
            ctx.save();

            // Apply zoom out
            const zoomFactor = 0.75; // 25% zoom out
            ctx.scale(zoomFactor, zoomFactor);

            // Apply camera offset - translate world so camera position appears at screen center
            const screenCenterX = canvas.width / (2 * zoomFactor);
            const screenCenterY = canvas.height / (2 * zoomFactor);

            // Apply camera translation without screen shake integration
            ctx.translate(screenCenterX - camera.x, screenCenterY - camera.y);

            // Update screen shake values separately (but don't apply to avoid drift)
            updateScreenShake();

            // Draw textured ground (with camera system)
            drawTerrain();

            drawWalls();

            // Update invincibility frames
            if (invincibilityFrames > 0) {
                invincibilityFrames -= 16; // Decrease by 16ms per frame
            }

            // Update power-ups
            updatePowerUps();

            updatePlayerPosition();
            spawnZombie();
            spawnSkeleton();
            updateZombies();
            updateSkeletons();
            updatePlayerBullets();
            updateEnemyBullets();
            updateMissiles();
            updateFragments();
            updateMuzzleFlashes();
            updateBloodSplatters();
            updateDamageNumbers();
            updateExplosions();
            spawnChest();
            
            // New logic to check for and remove enemies inside the base
            zombies = zombies.filter(zombie => {
                if (isInsideBase(zombie.x, zombie.y)) {
                    explosions.push({
                        x: zombie.x,
                        y: zombie.y,
                        radius: 0,
                        maxRadius: 50,
                        life: 1,
                        particles: []
                    });
                    return false;
                }
                return true;
            });
            
            skeletons = skeletons.filter(skeleton => {
                if (isInsideBase(skeleton.x, skeleton.y)) {
                     explosions.push({
                        x: skeleton.x,
                        y: skeleton.y,
                        radius: 0,
                        maxRadius: 50,
                        life: 1,
                        particles: []
                    });
                    return false;
                }
                return true;
            });

            checkCollisions();

            // Draw player with flashing effect if invincible
            if (invincibilityFrames > 0) {
                // Flash every 100ms while invincible
                if (Math.floor(invincibilityFrames / 100) % 2 === 0) {
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    drawPlayerFrame(ctx, player.x, player.y, player.frame, player.variant, player.direction);
                    ctx.restore();
                } else {
                    drawPlayerFrame(ctx, player.x, player.y, player.frame, player.variant, player.direction);
                }
            } else {
                drawPlayerFrame(ctx, player.x, player.y, player.frame, player.variant, player.direction);
            }

            // Draw subtle directional indicator
            let aimDx, aimDy;
            // Use same logic as shooting to determine aim direction
            if (gamepad && (gamepadAimX !== 0 || gamepadAimY !== 0)) {
                aimDx = gamepadAimX * GAMEPAD_AIM_SENSITIVITY;
                aimDy = gamepadAimY * GAMEPAD_AIM_SENSITIVITY;
            } else if (!gamepad && mouseMoved) {
                aimDx = mouseX - player.x;
                aimDy = mouseY - player.y;
            } else {
                aimDx = playerDirection.x;
                aimDy = playerDirection.y;
            }

            const aimMagnitude = Math.hypot(aimDx, aimDy);
            if (aimMagnitude > 0) {
                const normalizedDx = aimDx / aimMagnitude;
                const normalizedDy = aimDy / aimMagnitude;

                // Draw small directional dot
                const indicatorDistance = 64; // Distance from player center
                const indicatorX = player.x + normalizedDx * indicatorDistance;
                const indicatorY = player.y + normalizedDy * indicatorDistance;

                ctx.save();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(indicatorX, indicatorY, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }

            // Draw tree canopies AFTER player so player appears under foliage
            if (window.gameObjects && window.gameObjects.trees) {
                window.gameObjects.trees.forEach(tree => {
                    const visual = tree.visual;
                    ctx.save();
                    ctx.globalAlpha = 0.7; // 70% opacity
                    ctx.fillStyle = visual.foliageColor;
                    ctx.beginPath();
                    ctx.arc(visual.centerX, visual.canopyY, visual.canopySize/2, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.restore();
                });
            }

            drawZombies();
            drawSkeletons();
            drawBullets();
            drawWoodPlanks();
            drawStone();
            drawMissiles();
            drawFragments();
            drawBloodSplatters();
            drawMuzzleFlashes();
            drawDamageNumbers();
            drawExplosions();
            drawChests();

            // Restore canvas state (remove zoom and translation)
            ctx.restore();

            animationId = requestAnimationFrame(gameLoop);
        }

        window.onload = function() {
            resizeCanvas();
            // Ensure player is centered and camera is properly initialized
            player.x = 0;
            player.y = 0;
            initializeCamera();
            gameUI.style.display = 'flex';
            startMenu.style.display = 'flex';
            highSessionXP = parseInt(localStorage.getItem('zombieGameHighSessionXP')) || 0;
            startHighScoreSpan.textContent = `Best Session: ${highSessionXP} XP`;

            // Initialize XP system
            loadProgress();
            updateXPDisplay();

            isInMenu = true;
            updateMenuSelection();
            // Start the game loop immediately for menu input
            gameLoop();
            updateWeaponDisplay();
            updateHealthDisplay();
            // Draw character variants on start screen
            drawPlayerFrame(ctx1, char1Canvas.width / 2, char1Canvas.height / 2, 1, 0, 'down');
            drawPlayerFrame(ctx2, char2Canvas.width / 2, char2Canvas.height / 2, 1, 1, 'down');
            drawPlayerFrame(ctx3, char3Canvas.width / 2, char3Canvas.height / 2, 1, 2, 'down');
        };

        document.addEventListener('keydown', (e) => {
            const key = e.key;
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
            }
            if (key === ' ') {
                if (!spacePressed) {
                    spacePressed = true;
                    if (currentWeapon === 'assaultRifle') {
                        // Start automatic firing
                        shoot(mouseX, mouseY);
                        autoFireInterval = setInterval(() => {
                            if (spacePressed && currentWeapon === 'assaultRifle') {
                                shoot(mouseX, mouseY);
                            }
                        }, ASSAULT_RIFLE_FIRE_RATE);
                    } else {
                        // Single shot for other weapons
                        shoot(mouseX, mouseY);
                    }
                }
            }
            if (key === '1') {
                currentWeapon = 'axe';
                updateWeaponDisplay();
                updateAmmoDisplay();
            }
            if (key === '2') {
                currentWeapon = 'pistol';
                updateWeaponDisplay();
                updateAmmoDisplay();
            }
            if (key === '3') {
                currentWeapon = 'shotgun';
                updateWeaponDisplay();
                updateAmmoDisplay();
            }
            if (key === '4') {
                currentWeapon = 'assaultRifle';
                updateWeaponDisplay();
                updateAmmoDisplay();
            }
            if (key === '5') {
                currentWeapon = 'fragGrenade';
                updateWeaponDisplay();
                updateAmmoDisplay();
            }
            if (key === '6') {
                currentWeapon = 'nuke';
                updateWeaponDisplay();
                updateAmmoDisplay();
            }
            if (key === '7') {
                currentWeapon = 'missile';
                updateWeaponDisplay();
                updateAmmoDisplay();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            const key = e.key;
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
            if (key === ' ') {
                spacePressed = false;
                if (autoFireInterval) {
                    clearInterval(autoFireInterval);
                    autoFireInterval = null;
                }
            }
        });
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const rawX = e.clientX - rect.left;
            const rawY = e.clientY - rect.top;

            // Convert screen coordinates to world coordinates with camera system
            const zoomFactor = 0.75;
            const screenCenterX = canvas.width / 2;
            const screenCenterY = canvas.height / 2;

            // Convert to world coordinates accounting for zoom and camera position
            mouseX = camera.x + (rawX - screenCenterX) / zoomFactor;
            mouseY = camera.y + (rawY - screenCenterY) / zoomFactor;
            mouseMoved = true;
        });

        canvas.addEventListener('mouseleave', () => {
            mouseMoved = false;
        });
        
        canvas.addEventListener('mousedown', (e) => {
            if (!mousePressed) {
                mousePressed = true;
                if (currentWeapon === 'assaultRifle') {
                    // Start automatic firing
                    console.log('Starting assault rifle auto-fire');
                    shoot(mouseX, mouseY);
                    autoFireInterval = setInterval(() => {
                        if (mousePressed && currentWeapon === 'assaultRifle') {
                            console.log('Auto-firing assault rifle');
                            shoot(mouseX, mouseY);
                        } else {
                            console.log('Stopping auto-fire: mousePressed =', mousePressed, 'weapon =', currentWeapon);
                            clearInterval(autoFireInterval);
                            autoFireInterval = null;
                        }
                    }, ASSAULT_RIFLE_FIRE_RATE);
                } else {
                    // Single shot for other weapons
                    shoot(mouseX, mouseY);
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            console.log('Mouse up - stopping auto-fire');
            mousePressed = false;
            if (autoFireInterval) {
                clearInterval(autoFireInterval);
                autoFireInterval = null;
            }
        });

        // Touch swipe detection for weapon switching
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        const weapons = ['axe', 'pickaxe', 'pistol', 'shotgun', 'assaultRifle', 'fragGrenade', 'nuke', 'missile'];

        // Touch events for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent default touch behavior
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;

            // Store touch start position for swipe detection
            touchStartX = touchX;
            touchStartY = touchY;
            touchStartTime = Date.now();

            // Update mouse position for aiming with camera system
            const zoomFactor = 0.75;
            const screenCenterX = canvas.width / 2;
            const screenCenterY = canvas.height / 2;

            mouseX = camera.x + (touchX - screenCenterX) / zoomFactor;
            mouseY = camera.y + (touchY - screenCenterY) / zoomFactor;
            mouseMoved = true;

            // Shoot immediately on touch (will be overridden by swipe if detected)
            setTimeout(() => {
                // Only shoot if no swipe was detected
                if (Date.now() - touchStartTime < 200) {
                    shoot(touchX, touchY);
                }
            }, 50);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Prevent scrolling
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            // Convert touch coordinates to world coordinates with camera system
            const zoomFactor = 0.75;
            const screenCenterX = canvas.width / 2;
            const screenCenterY = canvas.height / 2;
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;

            mouseX = camera.x + (touchX - screenCenterX) / zoomFactor;
            mouseY = camera.y + (touchY - screenCenterY) / zoomFactor;
            mouseMoved = true;
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();

            // Detect swipe for weapon switching
            const touchEndTime = Date.now();
            const swipeTime = touchEndTime - touchStartTime;

            if (swipeTime < 300) { // Quick swipe
                const rect = canvas.getBoundingClientRect();
                const touch = e.changedTouches[0];
                const touchEndX = touch.clientX - rect.left;
                const touchEndY = touch.clientY - rect.top;

                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                const swipeDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // Minimum swipe distance of 50px
                if (swipeDistance > 50) {
                    const currentWeaponIndex = weapons.indexOf(currentWeapon);

                    // Horizontal swipes change weapons
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        if (deltaX > 0) {
                            // Swipe right - next weapon
                            const nextIndex = (currentWeaponIndex + 1) % weapons.length;
                            currentWeapon = weapons[nextIndex];
                        } else {
                            // Swipe left - previous weapon
                            const prevIndex = (currentWeaponIndex - 1 + weapons.length) % weapons.length;
                            currentWeapon = weapons[prevIndex];
                        }
                        updateWeaponDisplay();
                        updateAmmoDisplay();
                        updateWeaponButtons();
                        audioManager.playSound('buttonClick');

                        // Close drawer if open
                        closeWeaponDrawer();

                        // Show weapon change feedback
                        showWeaponChangeNotification();
                    }
                }
            }
        });

        char1Button.addEventListener('click', async () => {
            await audioManager.init();
            audioManager.playSound('buttonClick');
            player.variant = 0;
            startGame();
        });
        char2Button.addEventListener('click', async () => {
            await audioManager.init();
            audioManager.playSound('buttonClick');
            player.variant = 1;
            startGame();
        });
        char3Button.addEventListener('click', async () => {
            await audioManager.init();
            audioManager.playSound('buttonClick');
            player.variant = 2;
            startGame();
        });
        restartButton.addEventListener('click', async () => {
            await audioManager.init();
            audioManager.playSound('buttonClick');
            audioManager.stopBackgroundMusic();
            highSessionXP = parseInt(localStorage.getItem('zombieGameHighSessionXP')) || 0;
            startHighScoreSpan.textContent = `Best Session: ${highSessionXP} XP`;
            gameUI.style.display = 'flex';
            startMenu.style.display = 'flex';
            gameOverScreen.style.display = 'none';
            isInMenu = true;
            updateMenuSelection();
        });

        // Initialize mobile weapon drawer
        if (isMobile) {
            updateWeaponButtons();
        }

    </script>
</body>
</html>
